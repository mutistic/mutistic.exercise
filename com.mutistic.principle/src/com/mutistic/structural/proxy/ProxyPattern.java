package com.mutistic.structural.proxy;

import com.mutistic.utils.PrintUtil;

/**
 * @program 代理模式[Proxy Pattern]
 * @description 
 * @author mutisitic
 * @date 2018年8月21日
 */
public class ProxyPattern {
	public static void main(String[] args) {
		PrintUtil.ln("代理模式[Proxy Pattern]");
		PrintUtil.one("一、定义和本质:\r\n" + 
				"\r\n" + 
				"定义: 为其他对象提供一种代理以控制对这个对象的访问\r\n" + 
				"本质: 控制对象访问\r\n" + 
				"\r\n" + 
				"二、结构和说明:\r\n" + 
				"\r\n" + 
				"Proxy：代理对象，通常有一下功能：\r\n" + 
				"1、实现与具体的目标对象一样的接口，可以使用代理来替代具体的目标对象\r\n" + 
				"2、保存一个指向具体目标对象的引用，可以在需要的时候调用具体的目标对象\r\n" + 
				"3、可以控制对具体目标对象的访问，并可能负责创建和删除它\r\n" + 
				"\r\n" + 
				"Subject：目标接口，定义代理额具体目标对象的接口，可在任何使用具体目标对象的地方使用代理对象\r\n" + 
				"\r\n" + 
				"RealSubject：具体的目标对象，真正实现目标接口要求的功能\r\n" + 
				"\r\n" + 
				"三、理解:\r\n" + 
				"\r\n" + 
				"主要解决：在直接访问对象时带来的问题，比\r\n" + 
				"	如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），\r\n" + 
				"	直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。\r\n" + 
				"如何解决：增加中间层。\r\n" + 
				"\r\n" + 
				"1、代理模式的功能：代理模式是通过创建一个代理对象，用这个代理对象去代表真实的对象，客户端得到这个代理对象过后，\r\n" + 
				"对客户端没有什么影响，就跟得到了真实对象一样来使用。\r\n" + 
				"	当客户端操作这个代理对象时，实际上功能最终还是会由真实的对象来完成，只不过是通过代理操作的，也就是客户端操作代理，\r\n" + 
				"代理操作真正的对象。\r\n" + 
				"	正是因为有代理对象加载客户端和被代理的正式对象中间，相当于一个中转，那么在中转的时候就有很多花招可以玩，\r\n" + 
				"比如：权限验证，引用计数等\r\n" + 
				"\r\n" + 
				"2、具体目标和代理的关系：\r\n" + 
				"	从代理模式的结构图来看，好像是有一个具体目标内就有一个代理类，其实不是这样的。如果代理类能完全通过接口来操作它\r\n" + 
				"所代理的目标对象，那么代理对象就不需要知道具体的目标对象，这样就无需为每一个具体目标类都创建一个代理类。\r\n" + 
				"\r\n" + 
				"四、写法:\r\n" + 
				"\r\n" + 
				"4.1、代理的分类\r\n" + 
				"1、虚拟代理：根据需要来创建开销很大的对象，该对象只有在需要的时候才会被真正创建\r\n" + 
				"2、远程代理：用来在不同的底子控件上代理同一个对象，这个不同的地址空间可以是在本机，也可以在其他机器，\r\n" + 
				"	在Java里面最典型的就是RMI技术\r\n" + 
				"3、copy-on-write代理：在客户端操作的时候，只有对象确实改变了，才会真的拷贝一个目标对象，算是虚拟代理的一个分支\r\n" + 
				"	拷贝一个大的对象是很小号资源的，如果这个被拷贝的对象从上次操作过来，没有被修改过，那么再拷贝这个对象是没有必要的。\r\n" + 
				"可以使用代理来延迟拷贝的过程，可以等到对象被修改的时候才真的对他进行拷贝。\r\n" + 
				"	copy-on-write可以大大降低拷贝大对象的开销，因此算是一种优化方式，可以根据需要来拷贝或者克隆对象。\r\n" + 
				"\r\n" + 
				"4、保护(Protect or Access)代理：控制对原始对象的访问，如果有需要，可以给不同的用户提供不同的访问权限，以控制用户对原始对象的访问\r\n" + 
				"	保护代理是一种控制对原始对象访问的代理，多用于对象应该有不同的访问权限的时候。保护代理会检查调用者是否具有\r\n" + 
				"请求所必须的访问权限，如果没有相应的权限，那么就不会调用目标对象，从而实现对目标对象的保护。\r\n" + 
				"\r\n" + 
				"5、Cache代理：为那些昂贵的操作的结果提供临时的存储空间，一遍多个客户端可以共享这些结果\r\n" + 
				"6、防火墙(Firewall)代理：保证对象不被恶意用户访问和操作\r\n" + 
				"7、同步化(Synchronization)代理：使多个用户能够同时访问苗木表对象而没有冲突\r\n" + 
				"8、智能引用(Smart Reference)代理：在访问对象时执行一些附加操作，比如：对指向实际对象的引用计数、第一次引用一个持久对象时，讲其装入内存等\r\n" + 
				"\r\n" + 
				"这些代理类型中，最常见的是：虚拟代理、保护代理、远程代理、智能引用代理这几种。\r\n" + 
				"\r\n" + 
				"4.2、Java中的代理\r\n" + 
				"1、Java的静态代理：\r\n" + 
				"	通常把前面自己实现的代理模式，称为Java的静态代理。这种实现方式有一个较大的缺点，就是如果Subject接口发生变化，\r\n" + 
				"那么代理类和具体的目标实现都要变化，不是很灵活，而且也和OCP原则有冲突\r\n" + 
				"\r\n" + 
				"2、Java的动态代理：\r\n" + 
				"	通常把使用Java内建的对代理模式支持的功能来实现的代理称为Java的动态代理。动态代理与静态代理相比，\r\n" + 
				"明显的变化是：静态代理实现的时候，在Subject接口上定义很多的方法，但是动态代理类始终只有invoke方法。\r\n" + 
				"这样当Subject接口发生变化的时候，动态代理的接口就不需要跟着变化了。\r\n" + 
				"\r\n" + 
				"五、优点:\r\n" + 
				"\r\n" + 
				"1、职责清晰\r\n" + 
				"2、高扩展性\r\n" + 
				"3、智能化\r\n" + 
				"	\r\n" + 
				"	代理模式在客户端和被客户端访问的对象之间，引入了一定程度间接性，即中间件。客户是直接使用代理，\r\n" + 
				"让代理来与被访问的对象进行交互。\r\n" + 
				"	不同的代理类型，这种附加的间接性有不同的用途，也就是有不同的优点：\r\n" + 
				"1、远程代理：隐藏了一个对象存在于不同的地址空间的事实，也即是客户通过远程代理访问一个对象，\r\n" + 
				"根本就不关心个对象在哪里，也不关心如何通过网络去访问到这个对象，从客户的角度来讲，它只是在使用代理对象而已\r\n" + 
				"2、虚拟代理：可以根据需要来创建“大”对象，只有到必须创建对象的时候，虚拟代理才会创建对象，\r\n" + 
				"从而大大加快程序运行速度并节省资源。通过虚拟代理可以对系统进行优化。\r\n" + 
				"3、保护代理：可以在访问一个对象的前后，执行很多附加的操作，除了进行权限控制之外，还可以进行很多跟业务相关的处理，\r\n" + 
				"而不需要修改被代理的对象。也就是说，可以通过代理来给目标对象增加功能。\r\n" + 
				"4、智能引用代理：跟保护代理类似，也是允许在访问一个对象的前后，执行很多附加的操作，这样一来就可以做很多额外的事情，比如．引用计数等。\r\n" + 
				"\r\n" + 
				"六、缺点:\r\n" + 
				"\r\n" + 
				"1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂\r\n" + 
				"\r\n" + 
				"七、使用场景:\r\n" + 
				"\r\n" + 
				"1、远程代理：需要为一个对象在不同的地址空间提供局部代表的时候，可以使用远程代理\r\n" + 
				"2、虚拟代理：需要按照需要创建开销很大的对象的时候，可以使用虚拟代理\r\n" + 
				"3、保护代理：需要控制对原始对象的访问权限的时候，可以使用保护代理\r\n" + 
				"4、智能引用代理：需要在访问对象的时候执行一些附加操作的时候，可以使用智能引用代理\r\n" + 
				"\r\n" + 
				"\r\n" + 
				"具体场景：\r\n" + 
				"1、Windows 里面的快捷方式\r\n" + 
				"2、spring aop\r\n" + 
				"\r\n" + 
				"八、注意事项:\r\n" + 
				"\r\n" + 
				"1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制\r\n" + 
				"\r\n" + 
				"");
	}
}
