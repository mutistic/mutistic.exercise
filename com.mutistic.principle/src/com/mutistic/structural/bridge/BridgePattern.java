package com.mutistic.structural.bridge;

import com.mutistic.utils.PrintUtil;

/**
 * @program 桥接模式[Bridge Pattern]
 * @description 
 * @author mutisitic
 * @date 2018年9月7日
 */
public class BridgePattern {
	public static void main(String[] args) {
		PrintUtil.ln("桥接模式[Bridge Pattern]");
		PrintUtil.ln("一、定义、本质、原则:\r\n" + 
				"\r\n" + 
				"定义: 将抽象部分与它的实现部分分离，使它们都可以独立地变化\r\n" + 
				"本质: 分离抽象和实现\r\n" + 
				"原则: 体现了开闭原则：\r\n" + 
				"  体现开闭原则：通常引用桥接模式的地方，抽象部分和实现部分都是可以变化的，也就是应用会有两个变化维度，\r\n" + 
				"桥接模式就是找到这两个变化，并分别封装起来，从而合理的实现OCP\r\n" + 
				"  桥接模式很好的体现了：多用对象组合，少用对象继承\r\n" + 
				"\r\n" + 
				"二、结构和说明:\r\n" + 
				"\r\n" + 
				"Abstraction：抽象部分的接口。通常在这个对象里面，要维护一个实现部分的对象引用，在抽象对象里面的方法，\r\n" + 
				"需要调用实现部分的对象来完成。这个对象里面的方法，通常都是具体的业务相关的方法\r\n" + 
				"\r\n" + 
				"RefinedAbstraction：扩展抽象部分的接口，通常在这些对象里面，定义跟实际业务相关的方法，\r\n" + 
				"这些方法的实现通常会使用Abstraction中定义的方法，也可能需要调用实现部分的对象来完成\r\n" + 
				"\r\n" + 
				"Implementor：定义实现部分的接口，这个接口不用和Abstraction里面的方法一致，\r\n" + 
				"通常是由Implementor接口提供基本的操作，而Abstraction而定义的是基于这些基本操作的务方法，\r\n" + 
				"也就是说Abstraction定义了基于这些基本操作的较高层次的操作\r\n" + 
				"\r\n" + 
				"ConcreteImplementor：真正实现Implementor接口的对象\r\n" + 
				"\r\n" + 
				"三、理解:\r\n" + 
				"\r\n" + 
				"主要解决：在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活。\r\n" + 
				"如何解决：把这种多角度分类分离出来，让它们独立变化，减少它们之间耦合。\r\n" + 
				"\r\n" + 
				"1、什么是桥接：\r\n" + 
				"  所谓桥接，通俗点说就是在不同的东西之间搭一个桥，让他们能够连接起来，可以相互通讯和使用。\r\n" + 
				"那么在桥接模式中到底是给什么东西来搭桥呢？就是为被分离了的抽象部分和实现部分来搭桥。\r\n" + 
				"  在桥接模式中的桥接是单向的，也就是只能是抽象部分的对象去使用具体实现部分的对象，而不能反过来，也就是个单向桥。\r\n" + 
				"\r\n" + 
				"2、为何需要桥接：\r\n" + 
				"  为了达到让抽象部分和实现部分都可以独立变化的目的，在桥接模式中，是把抽象部分和实现分分离开来的，\r\n" + 
				"虽然从程序结构上是分开了，但是在抽象部分实现的时候，还是需要使用具体的实现的，抽象部分如何才能调用到\r\n" + 
				"具体实现部分的功能呢？很简单，搭个桥，让抽象部分通过这个桥就可以调用到实现分的功能了，因此需要桥接。\r\n" + 
				"\r\n" + 
				"3、如何桥接：\r\n" + 
				"  只要让抽象部分拥有实现部分的接口对象，这就桥接上了，在抽象部分就可以通过这个接口来调用具体实现部分的功能。\r\n" + 
				"也就是说，桥接在程序上就体现成在抽象部分拥有实现部分的接口对象，维护桥接就是维护这个关系。\r\n" + 
				"\r\n" + 
				"4、独立变化：\r\n" + 
				"  桥接模式的意图：使得抽象和实现可以独变化，都可以分别扩充。也就是说抽象部分和实现部分是一种非常松散的关系，\r\n" + 
				"从某个角度来讲，抽象部分和实现部分是可以完全分开的，独立的，抽象部分不过是一个使用实现部分对外接口的程序\r\n" + 
				"  如果这么看桥接模式的话，就类似于策略模式了，抽象部分需要根据某个策略，来选择真实的实现，\r\n" + 
				"也就是说桥接模式的抽象部分相当于策略模式的上下文。更原始的就直接类似于面向接口编程，通过接口分离的两个部分而己。\r\n" + 
				"但是桥接模式的抽象部分，是可以继续扩展和变化的，而策略模式只有上下文，是不存在所谓抽象部分的。\r\n" + 
				"  那抽象和实现为何还要组合在一起呢？原因是在抽象部分和实现部分还是存在内部联系的，\r\n" + 
				"抽象部分的实现通是需要调用实现部分的功能来实现的\r\n" + 
				"\r\n" + 
				"5、谁来桥接：\r\n" + 
				"  所谓谁来桥接，就是谁来负责创建抽象部分和实现部分的关系，说得更直白点，就是谁来负责创建Implementor的对象，\r\n" + 
				"并把它设置到抽象部分的对象里面去，这点对于使用桥接模式来说，是十分重要的一点。\r\n" + 
				"  大致有如下几种实现方式：\r\n" + 
				"  5.1、由客户端负责创建Implementor的对象，并在创建抽象部分的对象的时候，把它设置到抽象部分的对象里面去\r\n" + 
				"  \r\n" + 
				"  5.2、可以在抽象部分的对象构建的时候，由抽象部分的对象自己来创建相应的Implementor的对象，\r\n" + 
				"当然可以给他传递参数，它可以根据参数来选择并创建具体的Implementor的对象\r\n" + 
				"  两种情况：一种是需要外部传入参数，一种是不需要外部传入参数\r\n" + 
				"  \r\n" + 
				"  5.3、可以在Abstraction中选择并创建一个缺省的Implementor的对象，然后子类可以根据需要改变这个实现\r\n" + 
				"  直接在Abstraction的构造方法中，创建一个缺省的Implementor对象，然后子类根据需要，看是直接使用还是覆盖掉。\r\n" + 
				"  \r\n" + 
				"  5.4、也可以使用抽象工厂或者简单工厂来选择并创建具体的Implementor的对象，\r\n" + 
				"抽象部分的类可以诵过调用工厂的方法来获取Implementor的对象\r\n" + 
				"  对于这种方式，根据具体需要来选择，如果是想要创建一系列实现对象，那就使用抽象工厂，\r\n" + 
				"如果是创建单个的实现对象，那就使用简单工厂。\r\n" + 
				"  这种方法的优点是Abstraction类不用和任何一个Implementor类直接耦合。\r\n" + 
				"\r\n" + 
				"  5.5、如果使用Ioc/DI容器的话，还以通过Ioc/DI容器来创建具体的Implementor的对象，并注入回到Abstraction中\r\n" + 
				"  对于这种方式，Abstraction的实现就更简单了，只需要实现注入Implementor对象的方法就可以了，其它的Abstraction就不管了。\r\n" + 
				"  Ioc/DI容器会负责创建Implementor对象，并设置回到Abstraction对象中，使用Ioc/DI的方式，\r\n" + 
				"并不会改变Abstraction和Implementor的关系，Abstraction同样需要持有相应的Implementor对象，同样会把功能委托给Implementor对象去实现。\r\n" + 
				"\r\n" + 
				"四、写法:\r\n" + 
				"\r\n" + 
				"1、动态变换功能：\r\n" + 
				"  由于桥接模式中的抽象部分和实现部分是完全分离的，因此可以在运行时动态组合具体的真实实现，从而达到动态变换功能的目的。\r\n" + 
				"  从另外一个角度看，抽象部分和实现部分没有固定的绑定关系了，因此同一个真实实现可以被不同的抽象对象使用，\r\n" + 
				"反过来，同一个抽象也可以有多个不同的实现。\r\n" + 
				"\r\n" + 
				"2、退化的桥接模式：\r\n" + 
				"  如果Implementor只有一个实现，那么就没有必要创建Implementor接口了，这是一种桥接模式退化的情况。\r\n" + 
				"这个时候Abstraction和Implementor是一对一的关系，虽然如此，也还是要保持它们的分离状态，这样的话，\r\n" + 
				"它们才不会相互影响，才可以分别扩展。\r\n" + 
				"  也就是说，就算不要Implementor接口，也要保持Abstraction和Implementor是分离的，模式的分离机制仍然是非常有用的\r\n" + 
				"\r\n" + 
				"3、桥接模式和继承：\r\n" + 
				"  继承：是扩展对象功能的一种常见手段，通常情况下，继承扩展的功能变化纬度都是一纬的，\r\n" + 
				"也就是变化的因素只有一类。\r\n" + 
				"对于出现变化因素有两类的，也就是有两个变化纬度的情况，继承实现就会比较复杂。\r\n" + 
				"从理论上来说，如果用继承的方式来实现这种有两个变化纬度的情况，\r\n" + 
				"最后实际的实现类应该是两个纬度上可变数量的乘积。\r\n" + 
				"如果要在任何一个纬度上进行扩展，都需要实现另外一个纬度卜的可变数量那么个实现类，\r\n" + 
				"这也是为何会感到扩展起来很困难。而随着程序规模的加大，会越来越难以扩展和维护。\r\n" + 
				"  \r\n" + 
				"  桥接模式：就是用来解决这种有两个变化纬度的情况下，如何灵活的扩展功能的一个很好的方案。\r\n" + 
				"其实，桥接模式主要是把继承改成了使用对象组合，从而把两个纬度分开，让每一个纬度单独去变化，\r\n" + 
				"最后通过对象组合的方式，把两个纬度组合起来，每一种组合的方式就相当于原来继承中的一种实现，\r\n" + 
				"这样就有效的减少了实际实现的类的个数。\r\n" + 
				"从理论上来说，如果用桥接模式的方式来实现这种有两个变化纬度的情况，\r\n" + 
				"最后实际的实现类应该是两个纬度上可变数量的和\r\n" + 
				"  \r\n" + 
				"  从侧面体现了，使用对象组合的方式比继承来的更灵活\r\n" + 
				"\r\n" + 
				"4、典型的实现-JDBC：\r\n" + 
				"  在Java应用中，对于桥接模式有一个非常典型的例子，就是：应用程序使用JDBC驱动程序过行开发的方式。\r\n" + 
				"  所谓驱动程序，指的是按照预先约定好的接口来操作计算机系统或者是外围设备的程序。\r\n" + 
				"  基于JDBC的应用程序，使用JDBC的API相当于是对数据库茶瓯做的抽象的扩展，算作桥接模式的抽象部分；\r\n" + 
				"而具体的接口实现是由驱动来完成的，驱动这边自然就相当于桥接模式的实现部分了。\r\n" + 
				"而桥接的方式，不再是让抽象部分持有实现部分，而是采用了类似于工厂的做法，\r\n" + 
				"通过DriverManager来把抽象部分和实现部分对接起来，从而实现抽象部分和实现部分解耦\r\n" + 
				"  JDBC的这种架构，把抽象和具体分离开来，从而使得抽象和具体邮分都可以独立扩展。\r\n" + 
				"对于应用程而言，只要选用不同的驱动，就可以让程序操作不同的数据库，而无需更改应用程序，\r\n" + 
				"从而实现在不同的数库上移植。对于驱动程序而言，为数据库实现不同的驱动程序，并不会影响应用程序。\r\n" + 
				"  而且，JDBC的这种架构，还合理的划分了应用程序开发人员和驱动程序开发人员的边界。 \r\n" + 
				"\r\n" + 
				"5、广义桥接-Java中无处不桥接：\r\n" + 
				"  使用Java编写程序，一个很重要的原则就是“面向接口编程”，说得准确点应该是“面向抽象编程”，\r\n" + 
				"由于在Java丌发中，更多的使用接口而非抽象类，因此通就说成“面向接口编程”了。\r\n" + 
				"  接口把具体的实现和使用接口的客服程序分离开来，从而使得具体的实现和使用接口的客户程序可以分别扩展，而不会相互影响\r\n" + 
				"  \r\n" + 
				"  桥接模式中的抽象部分持有具体实现部分的接口，最终目的是需要通过调用具体实现部分的接口中的方法，\r\n" + 
				"来完成一定的功能，这跟直接使用接口没有什么不同，只是表现形式有点不一样。\r\n" + 
				"再说，使用接口的客户程序也可以持有相应的接口对象，这样从形式上就一样了。\r\n" + 
				"  也就是说，从某个角度来讲，桥接模式不过就是对“而向抽象编程”这个设计原则的扩展。\r\n" + 
				"正是通过具体实现的接口，把抽象部分和具体的实现分离开来抽象部分相当于是使用实现部分接口的客户程序，\r\n" + 
				"这样抽象部分和实现部分就松散耦合了，从而可以实现相互独立的变化。\r\n" + 
				"  这样一来，几乎可以把所有面向抽象编写的程序，都视作是桥接模式的体现，至少算是简化的桥接模式，\r\n" + 
				"就算是广义的桥接吧。而Java编程很强调“面向抽象编程”，因此，广义的桥接，在Java中可以说是无处不在。\r\n" + 
				"\r\n" + 
				"  从广义桥接模式的角度来看，熟悉的三层架构其实就是组合使用桥接模式。\r\n" + 
				"桥接模式是可以连续组合使用的，一个桥接模式的实现部分，可以作为下一个桥接模式的抽象部分此类推，\r\n" + 
				"可以从三层架构扩展到四层、五层、百到N层架构，都可以使用桥接模式来组合。\r\n" + 
				"  如果从本质的角度来看，基本上只要是面向抽象编写的Java程序，都可以视为是桥接模式的应用，\r\n" + 
				"都是让抽象和实现相分离，从而，使它们能独立的变化不过只要分离的目的达到了，叫不叫桥接模式就无所谓了。\r\n" + 
				"\r\n" + 
				"五、优点:\r\n" + 
				"\r\n" + 
				"1、分离抽象和实现部分\r\n" + 
				"2、更好的扩展性\r\n" + 
				"3、可动态切换实现\r\n" + 
				"4、可减少子类的个数\r\n" + 
				"\r\n" + 
				"六、缺点:\r\n" + 
				"\r\n" + 
				"1、桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程\r\n" + 
				"\r\n" + 
				"七、使用场景:\r\n" + 
				"\r\n" + 
				"1、如果不希望在抽象和实现部分采用固定的绑定关系，可以采用桥接模式，来把抽象和实现部分分开，\r\n" + 
				"然后在程序运行期间来动态的设置抽象部分需要用到的具体的实现，还可以动态切换具体的实现\r\n" + 
				"\r\n" + 
				"2、如果出现抽象部分和实现部分都应该可以扩展的情况，可以采用桥接模式，让抽象部分和实现部分可以独立的变化，\r\n" + 
				"从而可以灵活的进行单独扩展，而不是耦合在一起，扩展一方会影响到另一方\r\n" + 
				"\r\n" + 
				"3、如果希望实现部分的修改，不会对客户产生影响，可以采用桥接模式，客户是面向抽象的接口在运行，\r\n" + 
				"实现部分的修改，可以独立抽象部分，也就不会对客户产生影晌了，也可以说对客户是透明的\r\n" + 
				"\r\n" + 
				"4、如果采用继承的实现方案，会导致产生很多子类，对于这种情况，可以考虑采用桥接模式，\r\n" + 
				"分析功能变化的原因，是否能分离成不同的纬度，然后通过桥接模式来分离它们，从而减少了类的数目\r\n" + 
				"\r\n" + 
				"具体场景：\r\n" + 
				"1、Java中的JDBC\r\n" + 
				"\r\n" + 
				"八、注意事项:\r\n" + 
				"\r\n" + 
				"对于两个独立变化的维度，使用桥接模式再适合不过了\r\n" + 
				"");
	}
}
