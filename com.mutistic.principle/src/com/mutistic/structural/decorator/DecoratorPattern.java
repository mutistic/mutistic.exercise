package com.mutistic.structural.decorator;

import com.mutistic.utils.PrintUtil;

/**
 * @program 装饰模式[Decorator Pattern]
 * @description 
 * @author mutisitic
 * @date 2018年9月6日
 */
public class DecoratorPattern {
	public static void main(String[] args) {
		PrintUtil.ln("装饰模式[Decorator Pattern]");
		PrintUtil.ln("一、定义、本质:\r\n" + 
				"\r\n" + 
				"定义: 动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式比生成子类更为灵活\r\n" + 
				"本质: 动态组合\r\n" + 
				"\r\n" + 
				"二、结构和说明:\r\n" + 
				"\r\n" + 
				"Component：组件对象的接口，可以给这对象动态的添加职责。\r\n" + 
				"\r\n" + 
				"ConcreteComponent：具体的组件对象，实现组件对象接口，通常就是被装饰器装的原始对象，也就是可以给这个对象添加职责。\r\n" + 
				"\r\n" + 
				"Decorator：所有装饰器的抽象父类，需要定义一个与组件接口一致的接口，并持有一个Component对象，其实就是持有一个被装饰的对象。\r\n" + 
				"  注意这个被装饰的对象不一定是最原始的那个对象了，也可能是被其它装饰器装饰过后的对象，实现的同一个接口，也就是同一类型。\r\n" + 
				"\r\n" + 
				"ConcreteDecorator：实际的装饰器对象，实现具体要向被装饰对象添加的功能。\r\n" + 
				"\r\n" + 
				"三、理解:\r\n" + 
				"\r\n" + 
				"主要解决：一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。\r\n" + 
				"如何解决：将具体功能职责划分，同时继承装饰者模式。\r\n" + 
				"\r\n" + 
				"1、装饰模式的功能：\r\n" + 
				"  装饰模式能够实现动态的为对象添加功能，是从一个对象外部来给对象增加功能，相当于是改变了对象的外观。\r\n" + 
				"当装饰过后，从外部使用系统的角度看就不再是，使用原始的那个对象了，而是使用被一系列的装饰器装饰过后的对象。\r\n" + 
				"  这样就能够灵活的改变一个对象的功能，只要动态组合的装器发生了改变，那么最终所得到的对象的功能也就发生了改变\r\n" + 
				"  变相的还得到了另外一个好处，那就是装饰器功能的复用，可以给一个对象多次增加同一个装饰器，也可以用同一个装饰器装饰不同的对象。\r\n" + 
				"\r\n" + 
				"2、对象组合：\r\n" + 
				"  在面向对象设计中，有一条很基本的规则就是“尽量使用对象组合，而不是对象继承”来扩展和复用功能，装饰模式的思考起点就是这个规则\r\n" + 
				"\r\n" + 
				"3、装饰器：\r\n" + 
				"  装饰器实现了对被装饰对象的某些装饰功能，可以在装饰器里调用被装饰对象的功能，获取相应的值，这其实是一种递归。\r\n" + 
				"  在装饰器里不仅仅是可以给被装饰对象增加功能，还可以根需要选择是否调用被装饰对象的功能，\r\n" + 
				"如果不调用被装饰对象的功能，那就变成完全重新实现了，相当于动态修改了被装饰对象的功能。 \r\n" + 
				"  另外，各个装饰器之闷最好是完个独立的功能，不要有依赖，这样在进行装饰组合的时候，才没有先后顺序的限制，\r\n" + 
				"也就是先装饰谁和后装饰谁都应该是一样的，否则会降低装饰器组合的灵活性。\r\n" + 
				"\r\n" + 
				"4、装饰器和组件类的关系：\r\n" + 
				"  装饰器是用来装饰组件的，装饰器一定要实现和组件类一致的接口，保证它们是同一个类型，并具有同一个外观，\r\n" + 
				"这样组合完成的装饰才能够递归的调用下去。\r\n" + 
				"  组件类是不知道装饰器的存在的，装饰器给组件添加功能是一种透明的包装，组件类毫不知情。\r\n" + 
				"需要改变的是外部使用组件类的地方，现在需要使用包装后的类，接口是一样的，但是具体的实现类发生了改变。\r\n" + 
				"\r\n" + 
				"四、写法:\r\n" + 
				"\r\n" + 
				"1、退化形式：\r\n" + 
				"  如果仅仅只是想要添加一个功能，就没有必要再设计装饰器的抽象类了，\r\n" + 
				"直接在装饰器里曲实现跟组件一样的接口，然后实现相应的装饰功能就可以了。\r\n" + 
				"  但是建议最好还是设计上装饰器的抽象类，这样有利于程序的扩展。\r\n" + 
				"\r\n" + 
				"2、Java中的装饰模式应用：I/O流\r\n" + 
				"  I/0流结构和装饰模式的结构几乎是一致的：\r\n" + 
				"  2.1、InputStream就相当于装饰模式中的Component\r\n" + 
				"  2.2、其实FileInputStream、ObjectInputStream、StringBufferInputStream这几个对象是\r\n" + 
				"直接接继承了InputStream，还有几个直接继承InputStream的对象，比如：ByteArrayInputStream、PipedInputStream等。\r\n" + 
				"这些对象相当于装饰模式中的Concretecomponent，是可以被装饰器装饰的对象。\r\n" + 
				"  2.3、那么FilterInutstram就相当于装饰模式中的Decorator，而它的子类\r\n" + 
				"  DataInputStream、BfferedInputStrearm、LineNumberInputStream、PushbackInputStream 就相当于装饰模式中的ConcreteDecorator了。\r\n" + 
				"另外FilterInputStream和它的子类对象的构造器，都是传入组件Inputstrealll类型，\r\n" + 
				"  这打就完个符合装饰器的结构了。\r\n" + 
				"\r\n" + 
				"3、装饰模式和AOP：\r\n" + 
				"  AOP：Aspect Oriented Programming的缩写，意为：面向切面编程。\r\n" + 
				"  通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。\r\n" + 
				"AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。\r\n" + 
				"利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，\r\n" + 
				"提高程序的可重用性，同时提高了开发的效率\r\n" + 
				"\r\n" + 
				"  可以使用装饰模式实现类似AOP的功能\r\n" + 
				"\r\n" + 
				"五、优点:\r\n" + 
				"\r\n" + 
				"1、比继承更灵活\r\n" + 
				"2、更容易复用功能\r\n" + 
				"3、简化高层定义\r\n" + 
				"4、更好的扩展性，装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能\r\n" + 
				"\r\n" + 
				"六、缺点:\r\n" + 
				"\r\n" + 
				"1、会产生很多细粒度对象\r\n" + 
				"2、多层装饰比较复杂\r\n" + 
				"\r\n" + 
				"七、使用场景:\r\n" + 
				"\r\n" + 
				"1、如果需要在不影响其它对象的情况下，以动态、透明的方式给对象添加职责，可以使用装饰模式，这几乎就是装饰模式的主要功能\r\n" + 
				"2、如果不合适使用子类来进行扩展的时候，可以考虑使用装饰模式，因为装饰模式是使用的“对象组合\"的方式。\r\n" + 
				"所谓不适合用子类扩展的方式，比如：扩展功能需要的子类太多，造成子数目呈爆炸性增长。\r\n" + 
				"3、动态增加功能，动态撤销\r\n" + 
				"\r\n" + 
				"具体场景：\r\n" + 
				"1、Java中的I/O流\r\n" + 
				"2、Spring AOP功能\r\n" + 
				"\r\n" + 
				"八、注意事项:\r\n" + 
				"\r\n" + 
				"可代替继承\r\n" + 
				"");
	}
}
