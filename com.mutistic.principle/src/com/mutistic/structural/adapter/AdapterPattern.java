package com.mutistic.structural.adapter;

import com.mutistic.utils.PrintUtil;

/**
 * @program 适配器模式[Adapter Pattern]
 * @description 
 * @author mutisitic
 * @date 2018年8月21日
 */
public class AdapterPattern {
	public static void main(String[] args) {
		PrintUtil.println("适配器模式[Adapter Pattern] ");
		PrintUtil.printOne("一、定义和本质:\r\n" + 
				"\r\n" + 
				"定义: 将一个类的接口转换客户端希望的另外一个接口。适配器模式使得原本由于接口不兼容而能一起工作的那些类可以一起工作。\r\n" + 
				"本质: 转换匹配，复用功能\r\n" + 
				"\r\n" + 
				"二、结构和说明:\r\n" + 
				"\r\n" + 
				"Client: 客户端，调用自己需要的领域接口Target\r\n" + 
				"\r\n" + 
				"Target: 定义客户端需要的跟特定领域相关的接口(或类或子类或抽象类)\r\n" + 
				"\r\n" + 
				"Existing: 已经存在的接口(或类或子类或抽象类)，但与客户端要求的特定领域接口不一致，需要被适配目标\r\n" + 
				"\r\n" + 
				"Adapter: 适配器，把Existing适配成Client需要的Target，本身是实现或基层Target\r\n" + 
				"\r\n" + 
				"三、理解:\r\n" + 
				"\r\n" + 
				"主要解决: 主要解决在软件系统中，常常要将一些\"现存的对象\"放到新的环境中，而新环境要求的接口是现对象不能满足的。\r\n" + 
				"如何解决: 继承或依赖（推荐）。\r\n" + 
				"\r\n" + 
				"1、适配器模式的功能: \r\n" + 
				"	适配器模式的主要功能是进行转换匹配，目的是复用已有的功能，而不是来实现新的接口\r\n" + 
				"	适配器里面也可以实现功能，称这种适配器为智能适配器\r\n" + 
				"\r\n" + 
				"2、Existing和Target的关系: 适配器模式中被适配的接口Existing和适配成为的接口Target是没有任何关联的\r\n" + 
				"\r\n" + 
				"3、对象适配器: 其实现依赖于对象组合。\r\n" + 
				"\r\n" + 
				"4、类适配器: 其实现采用多重继承对一个接口与另一个接口进行匹配。由于Java不支持多重继承，所以不涉及类适配器。\r\n" + 
				"	但是可以通过继承类，实现接口的方式来实现类似 类适配器\r\n" + 
				"\r\n" + 
				"5、类适配器和对象适配器的权衡: \r\n" + 
				"5.1、从实现上: \r\n" + 
				"	类适配器: 使用对象继承的方式，是静态的定义方式。\r\n" + 
				"	对象适配器: 使用对象组合的方式，是动态组合的方式。\r\n" + 
				"5.2、从处理子类上: \r\n" + 
				"	类适配器: 由于适配器直接继承了Existing，使得适配器不能和Existing的子类一起工作，因为继承是个静态关系，\r\n" + 
				"		当适配器继承了Existing后，就不能去处理Existing的子类了。\r\n" + 
				"	对象适配器: 允许一个Existing和多个Existing，包括Existing和她所有的子类一起工作。因为对象适配器采用对象组合的关系。\r\n" + 
				"		只要对象类型正确，是不是子类都无所谓。\r\n" + 
				"5.3、从方法覆盖上: \r\n" + 
				"	类适配器: 适配器可以重新定义Existing的部分行为，相当于子类覆盖父类的部分实现方法。\r\n" + 
				"	对象适配器: 要重定义Existing的行为比较困难，这种情况下，需要定义Existing的子类来实现重定义，然后让适配器组合子类。\r\n" + 
				"5.4、从引用上: \r\n" + 
				"	类适配器: 仅仅引入了一个对象，不需要额外的引用来间接得到Existing\r\n" + 
				"	对象适配器: 需要额外的引用来间接得到Existing\r\n" + 
				"\r\n" + 
				"四、写法:\r\n" + 
				"\r\n" + 
				"1、适配器的常见实现: 适配器通常是一个类，一般会让适配器类去实现或继承Target接口，然后在适配器的具体实现类里面去调用Existing\r\n" + 
				"2、智能适配器: 可以在适配器的实现里面，加入新功能的实现\r\n" + 
				"3、适配多个Existing\r\n" + 
				"4、适配器Adapter实现的复杂程度，取决于Target和Existing的相似度，相似度越低复杂度越高\r\n" + 
				"5、默认适配: 为一个接口提供默认实现\r\n" + 
				"6、双向适配: 适配器也可以实现双向的适配，适配器可以同时适配Target和Existing\r\n" + 
				"\r\n" + 
				"五、优点:\r\n" + 
				"\r\n" + 
				"1、更好的复用性\r\n" + 
				"2、更好的可扩展性\r\n" + 
				"\r\n" + 
				"六、缺点:\r\n" + 
				"\r\n" + 
				"1、过多的使用适配器，会导致系统非常凌乱、不容易整体进行把握。\r\n" + 
				"2、Target和Existing的相似度非常低，如果仍然采用适配器模式，会导致复杂度过高。建议重构而且适配器模式。\r\n" + 
				"\r\n" + 
				"七、使用场景:\r\n" + 
				"\r\n" + 
				"1、如果需要使用一个已经存在的类，但接口并不符合需求，可以使用适配器模式，来吧已有的实现转成需要的接口。\r\n" + 
				"2、如果需要创建一个可复用的类，这个类可能和一些不兼容的类一起工作，可以使用适配器模式，按需适配。\r\n" + 
				"3、如果需要使用一些存在的子类，不能采用对每个子类适配，可以使用对象适配器，直接适配这些子类的父类。\r\n" + 
				"\r\n" + 
				"具体场景: \r\n" + 
				"1、JAVA JDK 1.1 提供了 Enumeration 接口，而在 1.2 中提供了 Iterator 接口，\r\n" + 
				"想要使用 1.2 的 JDK，则要将以前系统的 Enumeration 接口转化为 Iterator 接口，这时就需要适配器模式。 \r\n" + 
				"2、在 LINUX 上运行 WINDOWS 程序。 \r\n" + 
				"3、JAVA 中的 jdbc\r\n" + 
				"\r\n" + 
				"八、注意事项:\r\n" + 
				"\r\n" + 
				"适配器不是在详细设计时添加的，而是解决正在服役的项目的问题。\r\n" + 
				"");
	}
}
