package com.mutistic.structural.flyweight;

import com.mutistic.utils.PrintUtil;

/**
 * @program 享元模式[Flyweight Pattern]
 * @description 
 * @author mutisitic
 * @date 2018年8月31日
 */
public class FlyweightPattern {
	public static void main(String[] args) {
		PrintUtil.ln("享元模式[Flyweight Pattern]");
		PrintUtil.ln("一、定义、本质:\r\n" + 
				"\r\n" + 
				"定义: 运用共享技术有效地支持大量细粒度的对象\r\n" + 
				"本质: 分离与共享\r\n" + 
				"\r\n" + 
				"二、结构和说明:\r\n" + 
				"\r\n" + 
				"Flyweight：享元接口，通这个接口flyweight可以接受并作用于外部状态。通过这个接口传入外部的状态，\r\n" + 
				"在享元对象的方法处理中可能会使用这些外部的数据\r\n" + 
				"\r\n" + 
				"ConcreteFlyweight：具体的享元实现对象，必须是可共享的，需要封装flweight的内部状态\r\n" + 
				"\r\n" + 
				"UnsharedConcreteFlywelght：非共享的享元实现对象，并不是所有的Flyweight实现对象都需要共享。\r\n" + 
				"非共享的享元实现对象通常是对共享享元对象的组合对象。\r\n" + 
				"\r\n" + 
				"FlyweightFactory：享元工厂，主要用来创建并管理共享的相关对象，并对外提供访问共享享元的接口。\r\n" + 
				"\r\n" + 
				"Client：享元客户端，主要的作是维持一个对flweight的引用，计算或存储享元对象的外部状态，\r\n" + 
				"当然这里可以访问共享和不共享的flyweight对象。\r\n" + 
				"\r\n" + 
				"三、理解:\r\n" + 
				"\r\n" + 
				"主要解决：在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，\r\n" + 
				"直接返回在内存中已有的对象，避免重新创建。\r\n" + 
				"如何解决：用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象。\r\n" + 
				"\r\n" + 
				"1、变与不变：\r\n" + 
				"  享元模式设计的重点就在于分离变与不变，把一个对象的状态分成内部状态和外部状态，内部状态是不变的，外部状态是可变的。\r\n" + 
				"然后通过共享不变的部分，达到减少对象数量并节约内存的目的。在享元对象需要的时候，可以从外部传入外部状态给共享的对象，\r\n" + 
				"共享对象会在功能处理的时候，使用自己内部的状态和这些外部的状态。\r\n" + 
				"\r\n" + 
				"2、共享与不共享：\r\n" + 
				"  在享元模式中，享元对象又有共享与不共享之分，这种情况通常出现在跟组合模式合用的情况，通共享的是叶子对象，\r\n" + 
				"一般不共享的部分是由共享部分组合而成的，由于所有细粒度的叶子对象都己经缓存了，那么缓存组合对象就没有什么意义了\r\n" + 
				"\r\n" + 
				"3、内部状态和外部状态：\r\n" + 
				"  享元模式的内部状态，通指的是包含在享元对象内部的、对象本身的状态，通是独立于使用享元的场景的信息，\r\n" + 
				"一般创建过后就不再变化的状态，因此可以共享。\r\n" + 
				"  外部状态指的是享元对象之外的状态，取决于使用享元的场景，会根据使用场景而变化，因此不可共享。\r\n" + 
				"如果享元对象需要这些外部状态的话，可以从外部传递到享元对象里面，比如通过方法的参数来传递。\r\n" + 
				"  也就是说享元模式真正缓存和共享的数据是享元的内部状态，而外部状态是不应该被缓存共享的。\r\n" + 
				"  另外，内部状态和外部状态是独立的，外部状态的变化不应该影响到内部状态。\r\n" + 
				"\r\n" + 
				"4、实例池\r\n" + 
				"  在享元模式中，为了创建和管理共享的享元部分，引入了享元工厂，享元工厂中一般都包含有享元对象的实例池，\r\n" + 
				"享元对象就是缓存在这个实例池中的\r\n" + 
				"  所谓实例池：指的是缓存和管理对象实例的程序，通常实例池会提供对象实例的运行环境，并控制对象实例的生命周期\r\n" + 
				"  工业级的实例池实现上有两个最基本的难点：\r\n" + 
				"  一个就是动态控制实例数量，\r\n" + 
				"  一个就是动态分配实例来提供给外部使用这些都是需要算法来做保证的。\r\n" + 
				"\r\n" + 
				"  回到享元模式中来，享元工厂中的实例池可没有这么复杂，因为共享的享元对象基本上都是一个实例，\r\n" + 
				"一般不会现同一个享元对象有多个实例的情况，这样就不用去考虑动态创建和销毁享元对象实例的功能。\r\n" + 
				"另外只有一个实例，也就不存在动态调度的麻烦，反正就是它了。\r\n" + 
				"  这也主要是因为享元对象封装的多半是对象的内状态，这状态通常是不变的有一个实例就够了，\r\n" + 
				"不需要动态控制生命周期，也不需要动态调度，它只需要做一个缓存而已，没有上升到真上的实例池的高度。\r\n" + 
				"\r\n" + 
				"5、初始化共享对象：\r\n" + 
				"  在享元模式中，通是在第一次向享元工厂请求获取共享对象的时候，进行共享对象的初始化，而且多半都是在享元工厂内部实现，\r\n" + 
				"不会从外部传入共享对象。当然可以从外部传入一些创建共享对象需要的值，享元工厂可以按照这些值去初始化需要共享的对象，\r\n" + 
				"然后就把创建好的共享对象的实例放入享元工厂内部的缓存中，以后再请求这个共享对象的时候就不用再创建了。\r\n" + 
				"\r\n" + 
				"扩展1：权限管理：\r\n" + 
				"  几乎所有的权限系统都分成两个部分，一个是授权部分，一个是验证部分，为了解它们，首先解释两个基本的名词，安全实体和权限。\r\n" + 
				"  安全实体：就是被权限系统检测的对象。\r\n" + 
				"  权限：就是需要被校验的权限对象，比如查看、修改等。\r\n" + 
				"  \r\n" + 
				"  安全实体和权限通要一起描述才有意义，比如有这么个描述：“现在要检测登录人员对工资数据是否有查看的权限\"\r\n" + 
				"  “工资数据”这个安全实体和“查看\"这个权限一定要起描述。如果只出现安全实体描述，那就变成这样：“现在要检测登录人员对工资数据\"，\r\n" + 
				"对工资数据做什么操作，没有后面的操作，就不完成。当然只有权限描述也不行，那就变成这样：“现在要检测登录人员是对工资数据”\r\n" + 
				"，对谁的查看权限啊，也不完整。所以安全实体和权限通要一起描述\r\n" + 
				"\r\n" + 
				"扩展2：授权和验证：\r\n" + 
				"  所谓授权是指：把对某安全实体的某些权限分配给某人员的过程。\r\n" + 
				"  所谓验证是指：判断某个人员对某个安全实体是否拥有某个或某些权限的过程。\r\n" + 
				"  \r\n" + 
				"  也就是说，授权过程即是权限的分配过程，而验证过程则是权限的匹配过程在目前应用系统的开发中，\r\n" + 
				"多数是利用数据库来存放授权过程产生的数据，也就是说，授权是向数据库里面添加数据、或是维护数据的过程，\r\n" + 
				"而匹配过程就变成了从数据中获取相应数进行匹配的过程了。\r\n" + 
				"  \r\n" + 
				"扩展3：权限的两个特征：\r\n" + 
				"  特征1：权限的继承性：指的是：如果多个安全实体存在包含关系，而某个安全实体没有相应的权限限制，\r\n" + 
				"那么它会继承包含它的安全实体的相应权限。\r\n" + 
				"\r\n" + 
				"  特征2：权限的最近匹配原则：指的是，如果多个安全实体存在包含关系，而某个安全买体没有相应的权限限制，\r\n" + 
				"那么它会向上寻找并匹配相应权限限制，直到找到一个离这个安全实体最近的拥有相应权限限制的安全实体为止。\r\n" + 
				"如果把整个层次结构都寻找完了都没有匹配到相应权限制的诩，那就说明所有人对这个安全实体都拥有这个相应的权限限制。\r\n" + 
				"\r\n" + 
				"四、写法:\r\n" + 
				"\r\n" + 
				"1、复合享元：不需要共享的享元实现\r\n" + 
				"  在实际开发中，存在不需要共享的享元实现，这种情况多出现在组合结构中，对于使用已经缓存的享元组合出来的对象，\r\n" + 
				"就没有必要再缓存了，也就是把已经缓存的享元当做叶子节点，组合出来的组合对象就不需要再被缓存了。\r\n" + 
				"也把这种享元称为复合享元。\r\n" + 
				"  比如要给某人分配“薪资数据”这个安全实体的“修改”权限，那么一定会把“薪资数据”的“查看权限”也分配给这个人，\r\n" + 
				"如果按照前面的做法，这就需要分配两个对象，为了方便，干脆把这两个描述组合起来，打包成一个对象，\r\n" + 
				"命名成为“操作薪资数据”，那么分配权限的时候，可以这么描述：\r\n" + 
				"     把 “操作薪资数据” 分配给 张三\r\n" + 
				"  这句话的意思就相当于:\r\n" + 
				"     把 “薪资数据” 的 “查看”权限 分配给 张三\r\n" + 
				"     把 “薪资数据” 的 “修改”权限 分配给 张三\r\n" + 
				"  这样一来，“操作薪资数据”就相当于是一个不需要共享的享元，它实际由享元“薪资数据的查看权限”，\r\n" + 
				"和享元“薪资数据的修改权限”这两个享元组合而成，因此“操作薪资数据”本身也就不需要再共享了。\r\n" + 
				"\r\n" + 
				"2、对享元对象的管理：\r\n" + 
				"  虽然享元模式对于共享的享元对象实例的管理要求，没有实例池对实例管理的要求那么高，\r\n" + 
				"但是也还是有很多自身的特点功能，比如：引用计数、垃圾清除等。\r\n" + 
				"  所谓引用计数：就是享元工厂能够记录每个享元被使用的次数。\r\n" + 
				"  所谓垃圾：就是在缓存中存在，但是不再需要被使用的缓存中的对象。而垃圾清除，就是在不需要这些数据的时候，\r\n" + 
				"应该把这些数据从缓存中清除，释放相应的内存空间，以节省资源\r\n" + 
				"\r\n" + 
				"  2.1、实现引用计数的基本思路：\r\n" + 
				"  要实现引用计数，就在享元工厂里面定义一个Map，它的key值跟缓存享元对象的key是一样的，\r\n" + 
				"  而value就是被引用的次数，这样当外部每次获取该享元的时候，就把对应的引用计数取出来加1，然后再记录回去。\r\n" + 
				"\r\n" + 
				"  2.2、实现垃圾回收的基本思路：\r\n" + 
				"  要实现垃圾回收，首先要能确定哪些是垃圾？其次是何时回收？由谁来回收？如何回收？\r\n" + 
				"  解决了这些问题，也就能实现垃圾回收了。\r\n" + 
				"  确定哪些是垃圾的一个简单方案是这样的，定义一个缓存对象的配置对象，在这个对象中描述了缓存的开始时间和最长不被使用的时间，\r\n" + 
				"这个时候判断是垃圾的计算公式如下：当前的时间_缓存的开始时间 >= 最长不被使用的时间。\r\n" + 
				"当然，每次这个对象被使用的时候，就把那个缓存开始的时间更新为使用时的当前时间，也就是说如果一直有人用的话，这个对象是不会被判断为垃圾的。\r\n" + 
				"  何时回收的问题，当然是判断出来是垃圾了就可以回收了。\r\n" + 
				"  关键是谁来判断垃圾，还有谁来回收垃圾的问题。一个简单的方案是定义一个内部的线程，这个线程在享元工厂被创建的时候就启动运行。\r\n" + 
				"由这个线程每隔一定的时间来循环缓存中所有对象的缓存配置，看看是否是垃圾，如果是垃圾，那就可以启动回收了。\r\n" + 
				"  如何回收，这个就是直接从缓存的map对象中删除掉相应的对象，让这些对象没有一用的地方，那么这些对象就可以等着被虚拟机的垃圾回收来回收掉了。\r\n" + 
				"\r\n" + 
				"五、优点:\r\n" + 
				"\r\n" + 
				"1、减少对象的数量和创建，节省内存空间\r\n" + 
				"\r\n" + 
				"六、缺点:\r\n" + 
				"\r\n" + 
				"1、维护共享对象，需要额外开销\r\n" + 
				"2、提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，\r\n" + 
				"不应该随着内部状态的变化而变化，否则会造成系统的混乱\r\n" + 
				"\r\n" + 
				"七、使用场景:\r\n" + 
				"\r\n" + 
				"1、如果一个应用程序使用了大量的细粒度对象，可以使用享元模式来减少对象数量\r\n" + 
				"2、如果由于使用大量的对象，造成很大的存储开销，可以使用享元模式来减少对象数量，并兯约内存\r\n" + 
				"3、如果对象的大多数状态都可以转变为外状态，比如通过计算得到，或是外部传入等，可以使用享元模式来实现内部状态和外部状态的分离\r\n" + 
				"4、如果不考虑的外部状态，可以用相对较少的共享对象取代很多组合对象，可以使用享元模式来共享对象，然后组合对象来使用这些共享对象\r\n" + 
				"\r\n" + 
				"具体场景：\r\n" + 
				"1、JAVA 中的 String，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面。\r\n" + 
				"2、数据库的数据池\r\n" + 
				"\r\n" + 
				"八、注意事项:\r\n" + 
				"\r\n" + 
				"1、注意划分外部状态和内部状态，否则可能会引起线程安全问题。\r\n" + 
				"2、这些类必须有一个工厂对象加以控制。 \r\n" + 
				"");
	}
}
