package com.mutistic.structural.composite;

import com.mutistic.utils.PrintUtil;

/**
 * @program 组合模式[Composite Pattern]
 * @description 
 * @author mutisitic
 * @date 2018年8月24日
 */
public class CompositePattern {
	public static void main(String[] args) {
		PrintUtil.ln("组合模式[Composite Pattern]");
		PrintUtil.ln("一、定义和本质:\r\n" + 
				"\r\n" + 
				"定义: 将对象组合成树形结构以表示“部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性\r\n" + 
				"本质: 统一叶子对象和组合对象\r\n" + 
				"\r\n" + 
				"二、结构和说明:\r\n" + 
				"\r\n" + 
				"Component：抽象的组件对象，为组合中的对象什么接口，让客户端可以通过这个接口来访问和管理整个对象结构，\r\n" + 
				"可以在内部为定义的功能提供默认的实现\r\n" + 
				"\r\n" + 
				"Leaf：叶子节点对象，定义和实现叶子对象的行为，不再包含其他的子节点对象\r\n" + 
				"\r\n" + 
				"Composite：组合对象，通常会存储子组件即叶子节点，定义包含子组件的那些组件的行为，\r\n" + 
				"并实现在组件接口中定义的与子组件有关的操作\r\n" + 
				"\r\n" + 
				"Client：客户端，通过组件接口来操作组合结果里面的组件对象\r\n" + 
				"\r\n" + 
				"三、理解:\r\n" + 
				"\r\n" + 
				"主要解决：它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以向处理简单元素一样来处理复杂元素，\r\n" + 
				"从而使得客户程序与复杂元素的内部结构解耦。\r\n" + 
				"如何解决：树枝和叶子实现统一接口，树枝内部组合该接口。\r\n" + 
				"\r\n" + 
				"1、组合模式的目的：\r\n" + 
				"  让客户端不在区分操作的是组合对象还是叶子对象，而是以一个统一的方式来操作。实现这个功能关键是设计一个抽象的组件类，让它可以代表组合对象和叶子对象，\r\n" + 
				"\r\n" + 
				"2、对象树：\r\n" + 
				"  通常，组合模式会组合出树形结构，组成这个属性结构所使用的多个组件对象没救自然的形成了对象树\r\n" + 
				"  这意味着方式可以使用对象树来描述或者操作的功能，都可以考虑使用组合模式，比如XML或HTML文件格式\r\n" + 
				"\r\n" + 
				"3、组合模式中递归：\r\n" + 
				"  组合模式中的递归，指的是对象递归组合，不是递归算法\r\n" + 
				"  组合模式中的递归，是对象本身的递归，是对象的组合方式，是从设计上来讲的。在设计模式成为递归关联，是对象关联关系的一种\r\n" + 
				"\r\n" + 
				"4、Component中是否应该实现一个Component集合：\r\n" + 
				"  大多数情况下，一个Composite对象会持有子节点的集合。不声明在Component中的原因是，在父类来存放子类的实例对象，\r\n" + 
				"对于Composite节点来说是没什么问题的，Composite本身就要存放子节点。但是对于叶子节点来说会导致空间浪费，因为叶子节点是最小单位\r\n" + 
				"\r\n" + 
				"5、最大化Component定义：\r\n" + 
				"  由于要统一两种对象的操作，所以Component里面的方法主要是两种对象方法的和。这种实现是与类单一职责设计原则是冲突的\r\n" + 
				"一个父类应该只定义那些对它的之类有意义的操作。所以在Component中对组合对象的操作方法是对叶子对象没有意义的这种方法，\r\n" + 
				"提供默认的实现或是默认抛出不支持该功能的异常。组合对象按需覆盖该功能\r\n" + 
				"\r\n" + 
				"四、写法:\r\n" + 
				"\r\n" + 
				"1、子组件排序：\r\n" + 
				"  在某些应用中，实用组合模式的时候，需要按照一定的顺序来使用子组件对象，比如进行语法分析的时候，\r\n" + 
				"使用组合模式构建的抽象语法是，在解析执行的时候，是需要按照顺序执行的。此时可以考虑结合迭代器模式来实现顺序访问组件对象\r\n" + 
				"\r\n" + 
				"2、透明性实现方式、安全性实现方式：\r\n" + 
				"  针对在Compoent声明定义管理子组件的操作还是在Composite中，在不同的实现中，要进行安全性和透明性的权衡选择\r\n" + 
				"  安全性是指：从客户使用组合模式上看是否更安全。如果安全，那么不会有发生无操作的可能，能访问的防范都是被支持的功能\r\n" + 
				"  透明性是指：从客户使用组合模式上，是否需要区分到底是组合对象还是叶子对象。如果是透明的，那就不再区分，对客户端而言，\r\n" + 
				"都是组件对象，具体的类型对于客户而言是透明的，是客户无需关心的。\r\n" + 
				"\r\n" + 
				"2.1、透明性的实现：\r\n" + 
				"  如果把管理子组件的操作定义在Component中，那么客户端只需要面对Component，而无需关心具体的组件类型，这种实现方式\r\n" + 
				"就是透明性的实现。也是标准的组合模式的定义。\r\n" + 
				"  但是透明性的实现是以安全性为代价的，因为Component中管理子组件的操作对客户是透明的，当客户使用叶子对象使用管理\r\n" + 
				"子组件的操作就会出现异常，这样操作是不安全的。\r\n" + 
				"\r\n" + 
				"2.2、透明性和安全性实现方式的选择：\r\n" + 
				"  对于组合模式而言，在安全性和透明性上，会更看重透明性，毕竟组合模式的功能就是要让客户端对叶子对象和组合对象的使用具有一致性\r\n" + 
				"  而且对于安全性的实现，需要区分是组合对象还是叶子对象，但是有的时候在强制类型转换，强制类型转换反而是不够安全的，\r\n" + 
				"针对这种问题，需要在Component额外声明判断是组合对象还是叶子对象的方法，根据判断结果在强制转换\r\n" + 
				"  因此在使用组合模式时，建议多采用透明性的实现方式，Component提供默认实现，少采用安全性的实现方式\r\n" + 
				"\r\n" + 
				"3、父组件引用：\r\n" + 
				"  父组件引用指的是：子组件对象到父组件对象的引用\r\n" + 
				"  简单的方案：在保持父组件到子组件引用的基础上，在增加保持从子组件到父组件的引用，这样在删除或调整一个组件对象时，\r\n" + 
				"可以通过调整父组件的引用来实现。通常在组合对象添加、删除、调整子组件对象时，为子组件对象重新父组件的方式来维护父组件引用。\r\n" + 
				"\r\n" + 
				"4、环状引用：\r\n" + 
				"  环状引用指的是：在对象结构中，某个对象包含的子对象，或者子对象的子对象，或是子对象的子对象的子对象，经过N层后，\r\n" + 
				"出现所包含的子对象中有这个对象本身，从而在组合模式中的树形结构出现了环状引用。\r\n" + 
				"  简单来说就是A包含B，B包含C，C包含A，这种组合关系形成了环状引用，这是要避免的。\r\n" + 
				"  检测是否有环状引用的情况：简单方案是：记录每个组件从根节点开始的路径，环状引用的标志是在一条路由中，\r\n" + 
				"某个对象出现两次。因此通过这个特性来判断是否存在环状引用。\r\n" + 
				"\r\n" + 
				"五、优点:\r\n" + 
				"\r\n" + 
				"1、定义了包含基本对象和组合对象的类层次结构\r\n" + 
				"2、统一了组合对象和叶子对象\r\n" + 
				"3、简化了客户端调用\r\n" + 
				"4、更容易扩展，节点自有增加\r\n" + 
				"\r\n" + 
				"六、缺点:\r\n" + 
				"\r\n" + 
				"1、很难限制组合中的组件类型\r\n" + 
				"2、在使用组合模式时，组合对象和叶子对象的声明都是实现类，而不是接口，违反了依赖倒置原则\r\n" + 
				"\r\n" + 
				"七、使用场景:\r\n" + 
				"\r\n" + 
				"1、需要表示对象的部分-整体层次结构，可以选用组合模式，把整体和部分的操作统一起来，是的层次结构实现更简单，\r\n" + 
				"简化客户端的调用\r\n" + 
				"2、需要统一使用组合结构中所有对象\r\n" + 
				"\r\n" + 
				"具体场景：\r\n" + 
				"1、Java中Awt和Swing\r\n" + 
				"2、数据字典、树形菜单、文件夹\r\n" + 
				"\r\n" + 
				"八、注意事项:\r\n" + 
				"\r\n" + 
				"Component一般定义时为具体类、抽象类，而不是接口\r\n" + 
				"");
	}

}
