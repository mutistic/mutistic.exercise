package com.mutistic.behavioral.strategy;

import com.mutistic.utils.PrintUtil;

/**
 * @program 策略模式[Strategy Pattern]
 * @description 
 * @author mutistic
 * @date 2018年5月14日
 */
public class StrategyPattern {
	public static void main(String[] args) {
		PrintUtil.ln("策略模式[Strategy Pattern]");
		PrintUtil.ln("一、定义、本质、原则:\r\n" + 
				"\r\n" + 
				"定义: 定义一系列的算法，把它们封装起来，并且使它们可以相互替换。策略模式使得算法可独立于使用它的客户而变化\r\n" + 
				"本质: 分离算法，选择实现\r\n" + 
				"原则：体现了开闭原则和里氏替换原则\r\n" + 
				"  体现开闭原则：策略模式通过把一系列可变的算法进行封装，并定义出合理的使用结构，使得在系统出现新算法的时候，\r\n" + 
				"能很容易把新的算法加入到已有的系统中，而已有的实现不需要修改。\r\n" + 
				"  体现里氏替换原则：策略模式是一个扁平结构，一系列的实现算法的地位是平等的，都是实现同一个接口或者继承的同一个父类。\r\n" + 
				"这样只要使用策略的客户端保持面向抽象类型变成，就能够使用不同的策略的具体实现对象来配置它，从而实现一系列算法可以相互替换，\r\n" + 
				"\r\n" + 
				"二、结构和说明:\r\n" + 
				"\r\n" + 
				"Strategy：策略接口。用来约束一系列具体的策略算法。Context使用这个接口来调用具体的策略实现定义的算法\r\n" + 
				"\r\n" + 
				"ConcreteStrategy：具体的策略实现，也就是具体的算法实现\r\n" + 
				"\r\n" + 
				"Context：上下文。负责和具体的策略类交互，通常上下文会持有一个真正的策略实现，上下文可以让具体的策略类来获取上下文数据，\r\n" + 
				"甚至让具体的策略类来回调上下文的方法\r\n" + 
				"\r\n" + 
				"三、理解:\r\n" + 
				"\r\n" + 
				"主要解决：在有多种算法相似的情况下，使用 if...else 所带来的复杂和难以维护。\r\n" + 
				"如何解决：将这些算法封装成一个一个的类，任意地替换。\r\n" + 
				"\r\n" + 
				"1、策略模式的功能：\r\n" + 
				"  策略模式的功能是把具体的算法实现，从具体的业务处理里面独立出来，实现成为单独的算法类，从而形成一系列的算法，并让这些算法可以相互替换。\r\n" + 
				"  策略模式的重心不是如何来实现算法，而是处何组织、调用这些算法，从而让程序结构更灵活、具有更好的维护性和扩展性\r\n" + 
				"\r\n" + 
				"2、策略模式和if-else语句：\r\n" + 
				"  每个策略算法具体实现的功能，就是在if-else结构中的具体实现。\r\n" + 
				"  其实多个if-else语句表达的就是一个平等的功能结构，要么执行if，要么执行else，或者是elseif，这个时候，\r\n" + 
				"if块里面的实现和else块里面的实现从运行地位上来讲就是平等的\r\n" + 
				"  而策略模式就是把各个平等具体实现封装到单独的策略实现类了，然后通过上下文来与具体的策略类进行交互。\r\n" + 
				"  因此多个if-else语句可以考虑使用策略模式\r\n" + 
				"\r\n" + 
				"3、算法的平等性：\r\n" + 
				"  策略模式一个很大的特点就是各个策略算法的平等性。对于一系列具体的策略算法，其地位是完个一样的，\r\n" + 
				"正是因为这个平等性，才能实现算法之闻可以相互替换\r\n" + 
				"  所有的策略算法在实现上也是相互独立的，相互之间是没有依赖的。\r\n" + 
				"  所以可以这样描述这一系列策略算法：策略算法是相同行为的不同实现\r\n" + 
				"\r\n" + 
				"4、准来选择具体的策略算法：\r\n" + 
				"  在策略模式中，可以在两个地方来进行具体策略的选择：\r\n" + 
				"  一个是在客户端，在使用上下文的时候，由客户端来选择具体的策略算法，然后把这个策略算法没置给上下文。\r\n" + 
				"  一个是客户端不用关心，由上下文来选择具体的策略算法，比如容错恢复机制\r\n" + 
				"\r\n" + 
				"5、Strategy的实现方式：\r\n" + 
				"  Strategy都是使用的接口来定义的，这也是常见的实现方式。但是如果有多个算法具有公共功能，可以把Strategy实现成抽象类，\r\n" + 
				"然后把多个算法的功能功能实现到Strategy里面。结合模板模式\r\n" + 
				"\r\n" + 
				"6、运行时策略的唯一性：\r\n" + 
				"  运行期间，策略模式在每一个时刻只能使用一个具体的策略实现对象，虽然可以动态的在不同的策略实现中切换，但是同时只能使用一个。\r\n" + 
				"\r\n" + 
				"7、增加新的策略：\r\n" + 
				"  策略模式可以很灵活的扩展新的算法。具体的做法是：\r\n" + 
				"  先写一个策略算法类来实现新的要求，然后在客户端使用的时候指定，使用新的策略算法类就可以了。\r\n" + 
				"\r\n" + 
				"8、Context和Strategy的关系：\r\n" + 
				"  在策略模式中，通是上下文使用具体的策略实现对象，反过来，策略实现对象也可以从上下文获取所需要的数据，\r\n" + 
				"因此可以将上下文当参数传递给策略实现对象，这种情况下上下文和策略实现对象是紧密耦合的。\r\n" + 
				"  在这种情况下，上下文封装着具体策略对象进行算法运算所需要的数据，具体策略对象通过回调上下文的方法来获取这些数据。\r\n" + 
				"  甚至在某些情况下，策略实现对象还可以回调上下文的方法来实现一定的功能，这种使用场景下，上下文变相充当了多个策略算法\r\n" + 
				"实现的公共接口，在上下文定义的方法可以当做是所有或者是部分策略算法，使用的公共功能。\r\n" + 
				"  但是请注意，由于所有的策略实现对象都实现同一个策略接传入同个上下文，可能会造成传入的上下文数据的浪费，\r\n" + 
				"因为有的算法会使用这些数据，而有的算法不会使用，但是上下文和策略对象之闷交互的开销是存在的了。\r\n" + 
				"\r\n" + 
				"四、写法:\r\n" + 
				"\r\n" + 
				"1、策略模式扩展的实现方式：\r\n" + 
				"1.1、对于扩展上下文的方式：\r\n" + 
				"  这样实现，所有策略的实现风格更统一，策略需要的数据都统一从上下文来获取，这样在使用方法上也很统一。\r\n" + 
				"  另外，在上下文中添加新的数据：别的相应算法也可以用得上，可以视为公共的数据。\r\n" + 
				"  但缺点也很明显，如果这些数据只有一个特定的算法来使用，那么这些数据有些浪费。\r\n" + 
				"  另外每次添加新的算法都去扩展上下文，容易形成复杂的上下文对象层次，也未见得有必要。\r\n" + 
				"\r\n" + 
				"1.2、对于在策略算法的实现上添加自己需要的数据的方式：\r\n" + 
				"  这样实现，比较简单。但是缺点也很明显，跟其它策略实现的风格不一致，其它策略都是从上下文中来获取数据，\r\n" + 
				"而这个策略的实现一部分数据来自上下文，一部分数据来自自己，有些不统一。\r\n" + 
				"  另外，这样一来，外部使用这些策略算法的时候也不一样了，不太好以一个统一的方式来动态切换策略算法。\r\n" + 
				"\r\n" + 
				"2、容错恢复机制：\r\n" + 
				"  容错恢复机制是应用程序开发中非常常见的功能。容错恢复就是：程序运行的时候，正常情况下应该按照某种方式来做，\r\n" + 
				"如果按照某种方式来做发生错误的话，系统并不会崩溃，也不会就此不能继续向下运行了，而是有容忍出错的能力，\r\n" + 
				"不但能容忍程序运行出现错误，还提供以现错误后的备用方案，也就是恢复机制，来代替正常执行的功能，\r\n" + 
				"使程序继续向下运行。\r\n" + 
				"\r\n" + 
				"3、策略模式结合模板模式：\r\n" + 
				"  在实际应用策略模式的过程中，经常会出现一系列算法的实现上存在公共功能，甚至这一系列算法的实现步骤都是一样的，\r\n" + 
				"只是在某些局步骤上有所不同，这个时候，就需要对策略模式进行些许的变化使用了。\r\n" + 
				"  对于一系列算法的实现上存在公共功能的情况，策略模式可以有如下三种实现方式：\r\n" + 
				"  3.1、在上下文当中实现公共功能，让所有具体的策略算法回'周这些方法。\r\n" + 
				"  3.2、把策略的接口改成抽象类，然后在里曲实现具体算法的公共功能。\r\n" + 
				"  3.3、给所有的策略算法定义、个抽象的父类，计这个父类去实现策略的接口，然后这个父类里面去实现公共的功能\r\n" + 
				"  3.4、针对上述情况，就可以在这个抽象类里面定义算法实现的骨架，然后让具体的策略算法去实现变化的部分。\r\n" + 
				"这样的一个结构自然就变成了策略模式来结合模板模式了。抽象类等同于模板类，具体策略类等同于具体模板实现类。\r\n" + 
				"\r\n" + 
				"五、优点:\r\n" + 
				"\r\n" + 
				"1、定义一系列算法，算法之间可以自由切换\r\n" + 
				"2、避免多重条件语句\r\n" + 
				"3、更好的扩展性\r\n" + 
				"\r\n" + 
				"六、缺点:\r\n" + 
				"\r\n" + 
				"1、所有策略类都需要对外暴露，而且客户端必须了解每种策略的区别\r\n" + 
				"2、具体的策略类会导致增加了对象数目\r\n" + 
				"3、由于策略模式要求算法地位的平等性，所以策略模式只适合扁平的算法结构，\r\n" + 
				"\r\n" + 
				"七、使用场景:\r\n" + 
				"\r\n" + 
				"1、出现有许多相关的类，仅仅是行为有差别的情况下，可以使用策略模式来使用多行为中的一个来配置一个类的方法，实现算法动态切换\r\n" + 
				"2、出现同一个算法，有很多不同的实现的情况，可以使用策略模式来把这些“不同的实现”实现成为一个算法的类层次\r\n" + 
				"3、需要封装算法中，与算法相关的数据的情况，可以使用策略模式来避免暴露这些跟算法相关的数据结构\r\n" + 
				"4、出现抽象一个定义了很多行为的类，并且是通过多个if-else语句来选择这些行为的情况，可以使用策略模式来代替这些条件语句\r\n" + 
				"\r\n" + 
				"具体场景：\r\n" + 
				"JAVA AWT 中的 LayoutManager\r\n" + 
				"\r\n" + 
				"八、注意事项:\r\n" + 
				"\r\n" + 
				"如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题\r\n" + 
				"");
	}
}
