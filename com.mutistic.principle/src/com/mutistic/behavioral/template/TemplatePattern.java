package com.mutistic.behavioral.template;

import com.mutistic.utils.PrintUtil;

/**
 * @program 模板模式[Template Pattern]
 * @description 
 * @author mutisitic
 * @date 2018年8月27日
 */
public class TemplatePattern {
	
	public static void main(String[] args) {
		PrintUtil.one("模板模式[Template Pattern]");
		PrintUtil.ln("一、定义、本质、体现:\r\n" + 
				"\r\n" + 
				"定义: 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法是的子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤\r\n" + 
				"本质: 固定算法骨架\r\n" + 
				"体现: 提现了开闭原则和里氏替换原则\r\n" + 
				"\r\n" + 
				"二、结构和说明:\r\n" + 
				"\r\n" + 
				"AbstractClass：抽象类。用来定义算法骨架和原语操作，在这类里面，还可以提供算法的通用的实现\r\n" + 
				"\r\n" + 
				"ConcreteClass：具体实现类。用来实现算法骨架中的某些步骤，完成跟特定子类相关的功能\r\n" + 
				"\r\n" + 
				"三、理解:\r\n" + 
				"\r\n" + 
				"主要解决：一些方法通用，却在每一个子类都重新写了这一方法。\r\n" + 
				"如何解决：将这些通用算法抽象出来。\r\n" + 
				"\r\n" + 
				"1、模板模式的功能：\r\n" + 
				"  模板模式的功能在于固定算法骨架，而然具体算法实现可扩展\r\n" + 
				"  模板模式可以控制子类的扩展。因为在抽象父类中定义了算法的步骤，只是在某几个固定的方法才回调用到被子类实现的方法，\r\n" + 
				"因此只允许子类针对这几个方法来扩展，这个可以被子类覆盖以扩展的方法通常被称为 钩子方法。\r\n" + 
				"\r\n" + 
				"2、模板类为什么是抽象类而非接口：\r\n" + 
				"  首先要区分抽象类和接口的区别。\r\n" + 
				"  其次要知道，通常在 既要约束子类的行为，又要为子类提供通用功能的时候 使用抽象类\r\n" + 
				"  模板模式的定义恰好符合抽象类的原则。\r\n" + 
				"\r\n" + 
				"3、模板模式中的变与不变：\r\n" + 
				"  程序设计的一个很重要的思考点就是“变与不变”，也就是分析程序中那些功能是可变的，那些功能是不变的，把不变的部分抽象出来\r\n" + 
				"进行公共的实现，把变化的部分分离出去，用接口来封装隔离，或用抽象类约束子类行为。\r\n" + 
				"  模板模式很好的提现了这一点。模板类实现的就是不变的方法和算法骨架，而需要变化的地方，都通过抽象方法，\r\n" + 
				"把具体实现延迟到子类，还通过父类的定义来约束子类的行为，从而使系统能有更好的复用性和扩展性\r\n" + 
				"\r\n" + 
				"4、好莱坞原则：\r\n" + 
				"  好莱坞原则：不要给我们打电话，我们会给你打电话(don‘t call us, we‘ll call you)\r\n" + 
				"  模板模式很好的体现了这一点，作为父类的模板会在需要的时候，调用子类相应的方法，也就是由父类来找子类，而不是让子类找父类\r\n" + 
				"  这是一种反向的控制结构，依赖倒置\r\n" + 
				"\r\n" + 
				"5、在Java里能实现模板模式的原理：\r\n" + 
				"  能够实现的原理就在于Java的动态绑定采用的是“后期绑定”技术，对于出现子类覆盖父类方法的情况，在编译时是通过数据类型。\r\n" + 
				"运行时看实际的对象类型（new 出来的具体类），一句话：new谁就调用谁的方法\r\n" + 
				"  因此在使用模板模式的时候，虽然用的数据类型是模板类型，但是在创建类实例的时候是创建的具体的子类的实例，因此调用的时候，\r\n" + 
				"会被动态绑定到子类的方法上去，从而实现控制反转。其实在写父类的时候，它调用的方法是父类自己的抽象方法，只是在运行的\r\n" + 
				"时候被动态绑定到子类的方法上\r\n" + 
				"\r\n" + 
				"四、写法:\r\n" + 
				"\r\n" + 
				"4.1、通常在模板里面包含如下操作类型：\r\n" + 
				"1、模板方法：就是定义算法骨架的方法\r\n" + 
				"\r\n" + 
				"2、具体操作：\r\n" + 
				"  在模板中直接实现某些步骤的方法，通常这些步骤的实现算法是固定的，而且是不怎么变化的，因此就可以当做公共功能实现在模板里面。\r\n" + 
				"  如果不需要提供给子类访问这些方法的话，还可以是private的，这样一来，子类的实现就相对简单些。\r\n" + 
				"  如果是子类需要访问，可以把这些方法定义为protected final的，因为通常情况下，这些实现不能够被子类覆盖和改变了\r\n" + 
				"\r\n" + 
				"3、具体的AbstractClass操作：\r\n" + 
				"  在模板中实现某些公共功能，可以提供给子类使用，一般不是具体的算法步骤的实现，只是一些辅助的公共功能\r\n" + 
				"\r\n" + 
				"4、原语操作：\r\n" + 
				"  就是在模板中定义的抽象操作，通常是模板方法需要调用的操作，是必须的操作，而且在弗雷中还没有办法确定下来如何实现，\r\n" + 
				"需要子类来真正实现的方法\r\n" + 
				"\r\n" + 
				"5、钩子操作：\r\n" + 
				"  在模板中定义，并提供默认实现的操作。这些方法通常被视为可扩展点，但不是必须的，子类可以有选择的覆盖这些方法，\r\n" + 
				"以提供新的实现来扩展功能\r\n" + 
				"\r\n" + 
				"6、Factory Method：\r\n" + 
				"  在模板方法中，如果需要得到某些对象实例的话，可以考虑通过工厂模式来获取，吧具体的构建对象的实现延迟到子类中去\r\n" + 
				"\r\n" + 
				"4.2、Java回调机制与模板方法模式：\r\n" + 
				"  模板模式的一个目的，就是于让其他类来扩展或具体实现在模板中固定的算法骨架重的某些算法步骤。在标准的模板模式实现中。\r\n" + 
				"主要是使用继承的方法，来让父类在运行期间可以调用到子类的方法。\r\n" + 
				"  在Java开发中，可以通过Java回调技术，通过回调在接口中定义的方法，调用到具体的实现类中的方法，其本质同样是利用Java的\r\n" + 
				"动态绑定技术，在这种实现中，可以不把实现类写成单独的类，而是使用匿名内部类来实现回调方法。\r\n" + 
				"\r\n" + 
				"Java回调机制与模板方法模式比较：\r\n" + 
				"1、运行关系：\r\n" + 
				"  使用继承的方式：抽象方法和具体的关系，是在编译期间静态决定的，是类级关系。\r\n" + 
				"  使用Java回调机制：抽象发放和具体实现的关系是在运行期间动态决定的，是对象级的关系\r\n" + 
				"\r\n" + 
				"2、灵活性：\r\n" + 
				"  使用继承的方式：对于子类而言，就不能继承其他对象了，因为Java是单继承的\r\n" + 
				"  使用Java回调机制：是基于接口的，相较于继承方式更灵活一些。\r\n" + 
				"  从另外一方面话说，回调机制是通过委托的方式来组合功能，它的耦合强度要比继承低一点，这回提供更多的灵活性。\r\n" + 
				"比如某些模板实现的方法，在回调实现的时候可以不调用模板的方法，而是调用其他实现中的某些功能，也就是说功能\r\n" + 
				"不再局限在模板和回调实现上了，可以更灵活组织功能\r\n" + 
				"\r\n" + 
				"3、实现方式：\r\n" + 
				"  使用继承方式：相对Java回调机制更简单点，因为父类提供了实现的方法，子类如果不需要扩展，就不同具体实现了\r\n" + 
				"  使用Java回调机制：回调的接口需要把所有可能被扩展的方法都定义进去，这就导致实现的时候，不管是否需要扩展，\r\n" + 
				"都要实现这个方法，哪怕没有任何操作，只是转调模板中已有的实现，也都要写出来。\r\n" + 
				"  事实上，命令模式的时候Java回调，通过退化命令模式来实现了Java回调的功能，所以也有这样的说法：命令模式可以作为\r\n" + 
				"模板模式的一种替代实现，那就是因为可以使用Java回调来实现模板模式\r\n" + 
				"\r\n" + 
				"4.3、典型应用：排序：\r\n" + 
				"  模板模式的一个非常典型的应用，就是实现排序的功能\r\n" + 
				"  java.util.Collections类，里面实现了对列表排序的功能，它提供了一个静态的sort方法，接受一个列表和一个Comparator接口的实例，\r\n" + 
				"  这个方法实现的大致步骤：\r\n" + 
				"  1、想把列表转换成对象数组\r\n" + 
				"  2、通过Arrays的sort方法来对数组进行排序，传入Comparator接口的实例\r\n" + 
				"  3、然后再把排序号的数组的数据设置回到原来的列表对象中\r\n" + 
				"  这其中的算法步骤是固定的，也就是算法骨架是固定的了，只是其中具体比较数据大小的步骤，需要由外部来提供，也就是传入的\r\n" + 
				"Comparator接口的实例，就是用来实现数据比较的，在算法内部会通过这个接口来回调具体的实现\r\n" + 
				"\r\n" + 
				"排序到底是模板模式还是策略模式：\r\n" + 
				"1、认为是策略模式的实例：\r\n" + 
				"  首先排序实现，并没有如同标准的模板模式那样，使用子类来扩展父类，从表面上不太像模板模式\r\n" + 
				"  其实排序使用的Comparator的实例，可以看成是不同的算法实现，在具体排序时，会选择使用不同的Comparator实现，相当于是在切换算法的实现\r\n" + 
				"2、认为是模板模式的实例：\r\n" + 
				"  首先，模板模式的本事是固定算法骨架，虽然标准结构使用的继承方式，当时通过回调来实现，也不能说不是模板模式\r\n" + 
				"  其次，从整体程序上看，排序的算法并没有改变，不过是某些步骤的实现发生了变化，也就是说通过Comparator来切换的是不同的\r\n" + 
				"比较大小的实现，相对于整个排序算法而言，Comparator不过是其中的一个步骤而已。\r\n" + 
				"\r\n" + 
				"五、优点:\r\n" + 
				"\r\n" + 
				"1、封装不变部分，扩展可变部分。 \r\n" + 
				"2、提取公共代码，便于维护，实现代码复用。 \r\n" + 
				"3、行为由父类控制，子类实现\r\n" + 
				"\r\n" + 
				"六、缺点:\r\n" + 
				"\r\n" + 
				"1、算法骨架不容易升级\r\n" + 
				"2、每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大\r\n" + 
				"\r\n" + 
				"七、使用场景:\r\n" + 
				"\r\n" + 
				"1、需要固定算法骨架，实现一个算法的不变部分，并把可变的行为留给子类来实现\r\n" + 
				"2、各个子类中具有公共行为，应该抽取出来，集中在一个公共类中去实现，从而避免代码重复\r\n" + 
				"3、需要控制子类扩展的情况。模板模式会在特定的点来调用子类的方法，这样只允许在这些点进行扩展\r\n" + 
				"\r\n" + 
				"具体场景：\r\n" + 
				"1、spring 中对 Hibernate 的支持\r\n" + 
				"2、java.util.Collections的排序功能\r\n" + 
				"\r\n" + 
				"八、注意事项:\r\n" + 
				"\r\n" + 
				"为防止恶意操作，除钩子方法、原语操作外，一般模板方法都加上 final 关键词。\r\n" + 
				"");
	}

}
