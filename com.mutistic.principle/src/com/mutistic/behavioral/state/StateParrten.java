package com.mutistic.behavioral.state;

import com.mutistic.utils.PrintUtil;

/**
 * @program 状态模式[State Pattern]
 * @description
 * @author mutisitic
 * @date 2018年8月29日
 */
public class StateParrten {
	public static void main(String[] args) {
		PrintUtil.ln("状态模式[State Pattern]");
		PrintUtil.ln("一、定义、本质:\r\n" + 
			"\r\n" + 
			"定义: 允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类\r\n" + 
			"本质: 根据状态来分离和选择行为\r\n" + 
			"\r\n" + 
			"二、结构和说明:\r\n" + 
			"\r\n" + 
			"Context：环境，也称上下文。通常用来定义客户端需要的接口，同时维护一个具体处理当前状态的实例对象\r\n" + 
			"\r\n" + 
			"State：状态接口。用来封装于上下文的一个特定状态所对应的行为\r\n" + 
			"\r\n" + 
			"ConcreteState：具体实现状态处理的类，每个类实现一个状态的具体处理\r\n" + 
			"\r\n" + 
			"三、理解:\r\n" + 
			"\r\n" + 
			"主要解决：对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为。\r\n" + 
			"如何解决：将各种具体的状态类抽象出来。\r\n" + 
			"\r\n" + 
			"1、状态和行为：\r\n" + 
			"  所谓对象的状态，通常指的就是对象实例的属性的值：而行为指的就是对象的功能，具体点：行为多半可以对应到方法上\r\n" + 
			"  状态模式的功能就是分离状态的行为，通过维护状态的变化，来调用不同的状态对应的不同的功能。\r\n" + 
			"  也就是说，状态和行为是相关联的，它们的关系可描述为：状态决定行为\r\n" + 
			"  由于状态是在运行期被改变的，因此行为也会在运行期，根据状杰的改变而改变，看起来同一个对象，在不同的运行时刻，\r\n" + 
			"行为是不一样的，就像是类被修改了一样\r\n" + 
			"\r\n" + 
			"2、行为的平行性：\r\n" + 
			"  注意是平行性而不是平等性。所渭平行性指的是各个状态的行为所处的层次是一样的，相互是独立的、没有关联的，\r\n" + 
			"是根据不同的状态来决定走平行线的那一条，行为是不同的，当然对应的实现也是不同的，相互之间不可替换\r\n" + 
			"  而平等性强调的是可替换性，是同一行为的不同描述或实现，因此在同一个行为发生的时候，可以根条件来选择任意一个实现来进行相应的处理。\r\n" + 
			"  2.1、状态模式和策略模式：\r\n" + 
			"  状态模式的结构和策略模式的结构完全一样，但是，它们的目的、实现、本质都是完个不一样的。\r\n" + 
			"  行为之间的特性也是状态模式和策略模式一个很重要的区别：\r\n" + 
			"  状态模式的行为是平行性的，不可相互替换的\r\n" + 
			"  策略模式的行为是平等性的，是可以相互替换的\r\n" + 
			"\r\n" + 
			"3、上下文和状态处理对象：\r\n" + 
			"  在状态模式中，上下文是持有状态的对象，但是上下文自身并不处理跟状态相关的行为，而是把处理状态的功能委托给\r\n" + 
			"状态对应的状态处理类来处理。\r\n" + 
			"  在具体的状态处理类里面经常需要获取上下文自身的数据，甚至在必要的时候会回调上下文的方法，\r\n" + 
			"因此，通常将上下文自身当作一个参数传递给具体的状态处理类。\r\n" + 
			"  客户端一般只和上下文交互，客户端可以用状态对象来配置一个上下文，一旦配置完毕，就不再需要和状态对象交互了，\r\n" + 
			"客户端通常不负责运行期间状态的维护，也不负责决定到底后续使用哪一个具体的状态处理对象。\r\n" + 
			"\r\n" + 
			"4、不完美的OCP体验：\r\n" + 
			"  使用状态模式来修改和扩展功能，是没有完全遵循OCP原则的。由于状态的维护和转换在状态模式结构里面，\r\n" + 
			"不管是扩展了状态实现类，还是新添加了状态实现类，都需要修改状态维护和转换的地方，以使用新的实现。\r\n" + 
			"\r\n" + 
			"四、写法:\r\n" + 
			"\r\n" + 
			"1、创和销毁状态对象：\r\n" + 
			"  在应用状态模式的时候，有一个常见的考虑，就是：究竟何时创建和销毁状态对象。\r\n" + 
			"  常见的有几个选择：\r\n" + 
			"1.1、一个是当需要使用状态对象的时候创建．使用完后就销毁它们：\r\n" + 
			"选择场景：如果要进入的状态在运行时是不可知的，而且上下文是比较稳定的，不会经改变状态，而且使用也不频繁\r\n" + 
			"\r\n" + 
			"1.2、另一个是提前创建它们并且始终不销毁\r\n" + 
			"选择场景：如果状态改变很频繁，也就是需要频繁的创建状态对象，而且状态对象还存储着大量的信息数据\r\n" + 
			"\r\n" + 
			"1.3、还有一种是采用延迟加载和缓存合用的方式，就是当第一次需要使用状态对象的时候创建，使用完后并不销毁对象，\r\n" + 
			"而是把这个对象缓存起来，等待下一次使用，而且在合适的时候，会山缓存框架销毁状态对象\r\n" + 
			"选择场景：如果无法确定状态改变是否频繁，而且有些状态对象的状态数量大，有些比较小，一切都是未知的\r\n" + 
			"\r\n" + 
			"  事实上，在实际工程开发中，第三种方案是首选，因为它兼顾了前面两种方案的优点，而又避免了它们的缺点，\r\n" + 
			"几乎能适应各种情况的需要。只是这个方案在实现的时候，要实现一个合理的缓存柜架，而且要考虑多线程并发的问题，\r\n" + 
			"因为需要由缓存框架来在合适的时候销毁状态对象，因此实现上难度稍点。另外在实现中还可以考虑结合享元模式，\r\n" + 
			"通过享元模式来共享状态对象\r\n" + 
			"\r\n" + 
			"2、状态维护和状态转换的控制：\r\n" + 
			"  状态维护：指的就是维护状态的数据，就是给状态设置不同的状态值\r\n" + 
			"  状态转换：指的就是根据状态的变化，选择不同的状态处理对象。\r\n" + 
			"  \r\n" + 
			"  在状态模式中，通有两个地方可以进行状态的维护和转换控制。\r\n" + 
			"  2.1、在上下文当中：因为状态本身通常被实现为上下文对象的状态，因此可以在上下文里面进行状态维护，当然也就可以控制状态的转换\r\n" + 
			"  选择场景：一般情况下，如果状态转换的规则是一定的，一般不需要进行什么扩展规则，那么适合在上下文种统一进行状态的维护\r\n" + 
			"  \r\n" + 
			"  2.2、在状态的处理类里面：当每个状态处理对象处理完自身状态所对应的功能后，可以根需要指定后继的状态，\r\n" + 
			"以便让应用能正确处理后续的请求\r\n" + 
			"  选择场景：如果状态的转换取决于前一个状态动态处理的结果，或者是依赖于外部数据，为了增强灵活性，\r\n" + 
			"这种情况下，一般是在状态处理类里面进行状态的维护\r\n" + 
			"\r\n" + 
			"3、使用数据库来维护状态：\r\n" + 
			"  在实际开发中，还有一个方式来维护状态，那就是使用数据库，在数据库中存储下一个状态的识别数据，\r\n" + 
			"也就是说，维护下一个状态，演化成了维护下个状态的识别数据，比如状态编码。\r\n" + 
			"  这样在程序中，通过查询数据库中的数据来得到状态编码，然后再根据状态编码来创建以相应的状态对象，\r\n" + 
			"然后再委托相应的状态对象进行功能处理。\r\n" + 
			"  还有一种情况是直接把“转移\"通过序列化的方式记录到数据库中，这样会更灵活。\r\n" + 
			"  所谓转移：指的就是描述从A状态到B状态的这么一个转换变化\r\n" + 
			"\r\n" + 
			"4、模拟工作流：\r\n" + 
			"  简单实现：把流程数据存放在数据库里面，然后在程序里面自己来进行流程控制。\r\n" + 
			"对于简单的业务流程控制，可以使用状态模式来辅助进行流程控制，因为大部分这种流程都是状态驱动的。\r\n" + 
			"\r\n" + 
			"五、优点:\r\n" + 
			"\r\n" + 
			"1、简化应用逻辑控制\r\n" + 
			"2、更好的分离状态和行为\r\n" + 
			"3、更好的扩展性\r\n" + 
			"4、封装了转换规则。 \r\n" + 
			"5、枚举可能的状态，在枚举状态之前需要确定状态种类。 6、将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。 7、允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。 \r\n" + 
			"8、可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数\r\n" + 
			"\r\n" + 
			"六、缺点:\r\n" + 
			"\r\n" + 
			"1、显示化进行状态转换\r\n" + 
			"2、状态模式的使用必然会增加系统类和对象的个数。 \r\n" + 
			"3、状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。 \r\n" + 
			"4、状态模式对\"开闭原则\"的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，\r\n" + 
			"否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码\r\n" + 
			"\r\n" + 
			"七、使用场景:\r\n" + 
			"\r\n" + 
			"1、行为随状态改变而改变的场景：如果一个对象的行为取决于它的状态，而且它必须在运行时刻根状态来改变它的行为。可以使用状态模式，\r\n" + 
			"来把状态和行为分离开，虽然分离开了，但状态和行为是有对应关系的，可以在运行期间，通过改变状态，\r\n" + 
			"就能够调用到该状态对应的状态处理对象上去，从而改变对象的行为\r\n" + 
			"2、条件、分支语句的代替者：如果一个操作中含有庞大的多分支语句，而且这些分支依赖于该对象的状态。可以使用状态模式，\r\n" + 
			"把各个分支的处理分散包装到单独的对象处理类里面，这些分支对应的对象就可以不依赖于其它对象而独立变化了\r\n" + 
			"\r\n" + 
			"八、注意事项:\r\n" + 
			"\r\n" + 
			"在行为受状态约束的时候使用状态模式，而且状态不超过 5 个\r\n" + 
			"");
	}
}
