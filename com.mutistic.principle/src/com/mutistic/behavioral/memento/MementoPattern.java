package com.mutistic.behavioral.memento;

import com.mutistic.utils.PrintUtil;

/**
 * @program 备忘录模式[Memento Pattern]
 * @description 
 * @author mutisitic
 * @date 2018年8月30日
 */
public class MementoPattern {
	public static void main(String[] args) {
		PrintUtil.ln("备忘录模式[Memento Pattern]");
		PrintUtil.ln("一、定义、本质:\r\n" + 
				"\r\n" + 
				"定义: 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将对象恢复到原先保存的状态\r\n" + 
				"本质: 保存和恢复内部状态\r\n" + 
				"\r\n" + 
				"二、结构和说明:\r\n" + 
				"\r\n" + 
				"Memento：备忘录。主要用来存储原发器对象的内部状态，但是具体需要存储哪些数据是由原发器对象来决定的。\r\n" + 
				"另外备忘录应该只能由原发器对象来访问它内部的数据，原发器外部的对象不应该能访问到备忘录对象的内部数据，\r\n" + 
				"一般定义为窄接口（不声明任何方法）,标识对象的类型\r\n" + 
				"\r\n" + 
				"Originator：原发器。使用备忘录来保存某个时刻原发器自身的状态，也可以使用备忘录来恢复内部状态。\r\n" + 
				"\r\n" + 
				"MementoImpl：具体备忘录对象。实现备忘录窄接口，在Originator原发器内部中实现成私有的内部类，不让外部访问。同时可以声明为静态的\r\n" + 
				"\r\n" + 
				"Caretaker：备忘录管理者，或者称为备忘录负责人。主要负责保存备忘录对象，但是不能对备忘录对象的内容过行操作或检查。\r\n" + 
				"\r\n" + 
				"三、理解:\r\n" + 
				"\r\n" + 
				"1、备忘录模式的功能：\r\n" + 
				"  备忘录模的功能，首先是在不破坏封装性的前提下，捕获一个对象的内部状态。\r\n" + 
				"  这里要注意两点：\r\n" + 
				"  1.1、一个是不破坏封装性，也就是对象不能暴露它不应该暴露的细节；\r\n" + 
				"  1.2、另外一个是捕获的是对象的内部状态，而且通常还是运行期间某个时刻，对象的内部状态。\r\n" + 
				"  \r\n" + 
				"  捕获对象的内部状态原因和作用：\r\n" + 
				"  是为了在以后的某个时候，将该对象的状态恢复到备忘录所保存的状态，这才是备忘录真正的目的，前面保存状态就是为了后面恢复，\r\n" + 
				"虽然不是一定要恢复，但是目的是为了恢复。这也是很多理解备忘录模式的时候，忽视掉的地方，他们太关注备忘，而忽视了恢复，这是不全面的理解。\r\n" + 
				"  \r\n" + 
				"  捕获的状态存放的位置：\r\n" + 
				"  备忘录模式中，捕获的内部状态，存储在备忘录对象中。而备忘录对象，通常会被存储在原发器对象之外，也就是被保存状态的对象的外部，\r\n" + 
				"通常是存放在管理者对象里面\r\n" + 
				"\r\n" + 
				"2、备忘录对象：\r\n" + 
				"  在备忘录模式中，备忘录对象，通常就是用来记录原发器需要保存的状态的对象，简单点的实现，就是个封装数据的对象。\r\n" + 
				"  但是这个备忘录对象和普通的封装数据的对象还是有区别的，主要就是这个备忘录对象，一般只让原发器对象来操作，\r\n" + 
				"而不是像普通的封装数据的对象那样，谁都可以使用。为了保证这一点，通常会把备忘录对象作为原发器对象的内部类来实现，\r\n" + 
				"而且会实现成私有的，这就断绝了外部来访问这个备忘录对象的途径\r\n" + 
				"  但是备录对象需要保存在原发器对象之外，为了与外部交互，通常备忘录对象都会实现窄接口，来标识对象的类型。\r\n" + 
				"\r\n" + 
				"3、原发器对象：\r\n" + 
				"  原发器对象，就是需要被保存状态的对象，也是有可能需要恢复状态的对象。原发器一般会包含备忘录对象的实现。\r\n" + 
				"  通常原发器对象应该提供捕获某个时刻对象内部状态的方法，在这个方法里面，原发器对象会创建备忘录对象，\r\n" + 
				"把需要保存的状态数据设置到备忘录对象中，然后把备忘录对象提供给管理者对象来保存。\r\n" + 
				"\r\n" + 
				"4、管理者对象：\r\n" + 
				"  在备忘录模式中管理者对象，主要是负责保存备忘录对象。有以下几点要注意：\r\n" + 
				"  4.1、并不一定要特别的做出一个管理者对象来，广义地说，调用原发器获得备忘录对象后，备忘录对象放在哪里，\r\n" + 
				"哪个对象就可以算是管理者对象。\r\n" + 
				"  4.2、管理者对象并不是只能管理一个备忘录对象，一个管理者对象可以管理多个备忘录对象\r\n" + 
				"  4.3、狄义的管理者对象，是只管理同一类的备忘录对象，但是广义管理者对象是可以管理不同类型的备忘录对象的\r\n" + 
				"  4.4、管理者对象需要实现的基本功能主要就是：存入备忘录对象、保存备忘录对象、获取备忘录对象，\r\n" + 
				"如果从功能上看，就是一个缓存功能的实现，或者是一个简单的对象实例池的实现\r\n" + 
				"\r\n" + 
				"四、写法:\r\n" + 
				"\r\n" + 
				"1、窄接口和宽接口：\r\n" + 
				"  窄接口：管者只能看到备忘录的窄接口，它的实现里面通常没有任何的方法，只是一个类型标识，窄接口使得管理者只能将备忘录传递给其它对象。\r\n" + 
				"  宽接口：原发器能够看到一个宽接口，允许它访问所需的所有数据，来返回到先前的状态。理想状况是：\r\n" + 
				"只允许生成备忘录的原发器来访问该备忘录的内部状态，通常实现成为原发器内的一个私有内部类。\r\n" + 
				"\r\n" + 
				"  备忘录模式的标准实现方式，那就是窄接口没有任何的方法，把备忘录对象实现成为原发器刈象的私有内类。\r\n" + 
				"  那么能不能在窄接口里面提供备忘录对象对外的方法，，变相对外提供一个宽接口？\r\n" + 
				"  通常情况是不会这么做的，因为这样一来，所有能拿到这个接口的对象就可以通过这个接口来访问备忘录内部的数据或是功能，\r\n" + 
				"这违反了备忘录模式的初衷，备忘录模式要求“在不破坏封性的前提下”，如果这么做，那就等于是暴露了内部细节，\r\n" + 
				"因此，备忘录模式买现的时候，对外多是采用窄接口，而且通常不会定义任何方法。\r\n" + 
				"\r\n" + 
				"2、使用备忘录的潜在代价：\r\n" + 
				"  标准的备忘录模式的实现机制是依靠缓存来实现的，因此，当需要备忘的数据量较大时，或者是存储的备忘录对象数据量不大\r\n" + 
				"但是数量很多的时候，或者是用户很频繁的创建备忘录对象的时候，这些都会导致非常大的开销。\r\n" + 
				"  因此在使用备忘录模式的时候，一定要好好思考应用的环境，如果使用的代价太高，就不要选用备忘录模式，可以采用其它的替代方案\r\n" + 
				"\r\n" + 
				"3、增量存储：\r\n" + 
				"  如果需要频繁的创建备忘录对象，而且创建和应用备忘录对象来恢复状态的顺序是可控的，那么可以让备忘录进行增量存储，\r\n" + 
				"也就是备忘录可以仅仅存储原发器内部相对于上次存储状态后的增量改变。\r\n" + 
				"  比如，在命令模式实现可撤销命令的实现中，就可以使用备忘录来保存每个命令对应的状态，然后在撤销命令的时候，\r\n" + 
				"使用备忘录来恢复这些状态。由于命令的历史列表是按点命令操作的顺序来存放的，也是按照这个历史列表来进行取消和重做的，\r\n" + 
				"因此顺序是可控的。那么这种情况，还可以让备忘录对象只存储一个命令所产生的增量改变而不是它所影响的每一个对象的完整状态。\r\n" + 
				"\r\n" + 
				"4、结合原型模式：\r\n" + 
				"  在原发器对象创建备忘录对象的时候，如果原发器对象中全部或者大部分的状态都需要保存，一个简洁的方式就是直接克隆一个原发器对象。\r\n" + 
				"也就是说，这个时候备忘录对象里面存放的是一个原发器对象的实例\r\n" + 
				"\r\n" + 
				"5、离线存储：\r\n" + 
				"  标准的备忘录模式，没有讨论离线存储的实现。\r\n" + 
				"  事实上，从备忘录模式的功能和实现上，是可以把备忘录的数实现成为离线存能的，也就是不仅限于存储于内存中，\r\n" + 
				"可以把这些备忘数据存储到文件中、xml中、数据库中，从而支持跨越会话的备份和恢复功能\r\n" + 
				"  离线存储甚至能帮助应对应用崩溃，然后关闭重启的情况，应用重启过后，从离线存储里面获取相应的数据，\r\n" + 
				"然后重新没置状态，恢复到崩溃前的状态\r\n" + 
				"\r\n" + 
				"6、结合命令模式：\r\n" + 
				"  可以实现可撤销操作，存储式恢复，意思就是把操作前的状态记录下来，然后要撤销操作的时候就直接恢复回去就可以了\r\n" + 
				"\r\n" + 
				"五、优点:\r\n" + 
				"\r\n" + 
				"1、给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态。 \r\n" + 
				"2、更好的封装性：实现了信息的封装，使得用户不需要关心状态的保存细节\r\n" + 
				"3、窄接口和宽接口\r\n" + 
				"\r\n" + 
				"六、缺点:\r\n" + 
				"\r\n" + 
				"1、可能会导致高开销，消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存\r\n" + 
				"\r\n" + 
				"七、使用场景:\r\n" + 
				"\r\n" + 
				"1、如果必须保存一个对象在某一个时刻的全部或者部分状态，这样在以后需要的时候，可以把该对象恢复到先前的状态。\r\n" + 
				"可以使用备忘录模式，使用备录对象来封装和保存需要保存的内部状态，然后把备忘录对象保存到管理者对象里面，\r\n" + 
				"在需要的时候，再从管理者对象里面获取备忘录对象，来恢复对象的状态\r\n" + 
				"2、如果需要保存一个对象的内部状态，但是如果用接口来让其它对象百接得到这些需要保存的状态，\r\n" + 
				"将会暴露对象的实现细节并破坏对象的封装性。可以使用备忘录模式，把备忘录对象实现成为原发器对象的内部类，\r\n" + 
				"而且是私有的，从而保证只有原发器对象才能访问该备忘录对象。这样既保存了需要保存的状态，\r\n" + 
				"又不会暴露原发器对象的内部实现细节。\r\n" + 
				"\r\n" + 
				"具体场景：\r\n" + 
				"1、Windows 里的Ctrl+Z恢复操作\r\n" + 
				"2、浏览器中的后退操作\r\n" + 
				"3、数据库的事务管理\r\n" + 
				"\r\n" + 
				"八、注意事项:\r\n" + 
				"\r\n" + 
				"1、为了符合迪米特原则，还要增加一个管理备忘录的类。 \r\n" + 
				"2、为了节约内存，可使用原型模式+备忘录模式\r\n" + 
				"");
	}
}
