package com.mutistic.behavioral.mediator;

import com.mutistic.utils.PrintUtil;

/**
 * @program 中介者模式[Mediator Pattern]
 * @description 
 * @author mutisitic
 * @date 2018年8月21日
 */
public class MediatorPattern {
	public static void main(String[] args) {
		PrintUtil.ln("中介者模式[Mediator Pattern]");
		PrintUtil.one("一、定义和本质:\r\n" + 
				"\r\n" + 
				"定义: 用一个中介对象来封装一系列的对象交付。终结者是的各对象不需要显式地相互引用，\r\n" + 
				"	从而而使其耦合松散，而且可以独立的改变他们之间的交互\r\n" + 
				"本质: 封装交互\r\n" + 
				"原则：符合迪米特原则\r\n" + 
				"\r\n" + 
				"二、结构和说明:\r\n" + 
				"\r\n" + 
				"Mediator: \r\n" + 
				"	中介者接口。在内部定义各个同事之间交付需要的方法，可以是公共的通讯方法，比如changed方法。也可以是小范围的交互方法。\r\n" + 
				"\r\n" + 
				"ConcreteMediator: \r\n" + 
				"	具体中介者实现对象。需要了解并维护各个同事对象，并负责具体的协调各同事对象的交互关系\r\n" + 
				"\r\n" + 
				"Colleague: \r\n" + 
				"	同事类的定义，通常实现为抽象类，主要负责约束同事对象的类型，并实现一些具体同事内类之间的公共功能，\r\n" + 
				"	比如: 每个具体同事类都应该知道中介者对象，也及时具体同事类都会持有中介者对象，就可以定义到这个类中\r\n" + 
				"\r\n" + 
				"ConcreteColleague: \r\n" + 
				"	具体的同事类，实现自己的业务，在需要与其他同事通讯的时候，就与自由的中介者通信，中介者会负责与其他的同事交互。\r\n" + 
				"\r\n" + 
				"三、理解:\r\n" + 
				"\r\n" + 
				"主要解决：对象与对象之间存在大量的关联关系，这样势必会导致系统的结构变得很复杂，同时若一个对象发生改变，我们也需要跟踪与之相关联的对象，同时做出相应的处理。\r\n" + 
				"如何解决：将多个类相互耦合新城的网状结构分离为星型结构(局域网就是星型结构)。\r\n" + 
				"\r\n" + 
				"1、中介者的功能: 就是封装对象之间的交互。如果一个对象的操作会引起其它相关对象的变化，或者是某个操作需要引起其它对象的后续或连带操作，\r\n" + 
				"而这个对象又不希望自己来处理这些关系，那么就可以委托给中介者，需要的时候通知中介者，由中介者完成与其他对象的交互。\r\n" + 
				"	反之亦然，所有的对象都是和中介者对象进行通信，相互之间不再交互。这样能够集中的控制这些对象的交互关系，\r\n" + 
				"这样有什么变化的时候，修改起来就很方便。\r\n" + 
				"\r\n" + 
				"2、Mediator中介者接口: Mediator接口的使用取决于时候回提供多个不同的中介者实现。如果明确只有一个ConcreteMediator中介者实现的话，\r\n" + 
				"	并且预计中也没有需要扩展的要求，那么就可以不定义Mediator，让同事对象直接使用中介者对象。\r\n" + 
				"	反之就需要定义Mediator，各个同事对象来面向中介者接口编程，而无需关心具体的中介者实现。\r\n" + 
				"\r\n" + 
				"3、Colleague关系：在中介者模式中，要求这些内都要继承相同的类，也就是说，这些对象从某个角度讲是同一个类型，算是兄弟对象。\r\n" + 
				"	正式因为这些对象之间的交互关系复杂，才产生了把这些交互关系分离出去，单独做成中介者对象。这些对象在中介者对象中就被称之为同事对象\r\n" + 
				"\r\n" + 
				"4、Mediator和Colleague的关系：中介者对象和同事对象之间是相互依赖的。\r\n" + 
				"\r\n" + 
				"5、如果实现同事和中介者的通信：\r\n" + 
				"	实现方式一：在Mediator接口中定义一个特殊的通知接口，作为一个通用的方法，各个同事类调用这个方法。\r\n" + 
				"	实现方式二：不拘泥于中介者模式，可以采用观察者模式，把Mediator实现为观察者Observer，把Colleague实现成为Subject。\r\n" + 
				"这样同事类发生了改变，会通知Mediator。Mediator在接到通知后，会与相应的同事对象进行交互。观察者模式称Mediator为。\r\n" + 
				"\r\n" + 
				"四、写法:\r\n" + 
				"\r\n" + 
				"1、标准的中介者模式在实际使用中的困难：\r\n" + 
				"1.1、是否有必要为同事对象定义一个公共的父类？\r\n" + 
				"	大家都知道，Java是单继承的，为了使用中介者模式，就让这些同事对象继承一个父类，这是很不好的：\r\n" + 
				"再说了，这个父类目前也没有什么特别的公共功能，也就是说继承它也得不到多少好处。\r\n" + 
				"	在实际开发中，很多相互交互的对象本身是没有公共父类的，强行加上一个父类，会让这些对象实现起来特别别扭。\r\n" + 
				"	\r\n" + 
				"1.2、同事类有必要持有中介者对象吗？\r\n" + 
				"	同事类需要知道中介者对象，以便当它们发生改变的时候，能够通知中介者对象，但是否需要作为属性，并通过构造方法传入，这么强的依赖关系呢？\r\n" + 
				"	也可以有简单的方式去通知中介对象，比如把中介对象做成单例，直接在同事类的方法里面去调用中介者对象。\r\n" + 
				"\r\n" + 
				"1.3、是否需要中介者接口？\r\n" + 
				"	在实际开发中，很常见的情况是不需要中介者接口的，而且中介者对象也不需要创建很多个实例，\r\n" + 
				"因为中介者是用来封装和处理同事对象的关系的，它一般是没有状态需要护的，因此中介者涌常可以实现成单例。\r\n" + 
				"1.4、中介者对象是否需要持有所有的同事？\r\n" + 
				"	虽说中介者对象需要知道所有的同事类，这样中介者才能与它们交互。但是是否需要做为属性这么强烈的依赖关系，\r\n" + 
				"而且中介者对象在不同的关系维护上，可能会需要不同的同事对象的实例，因此可以在中介者处理的方法里面去创建、\r\n" + 
				"或者获取、或者从参数传入需要的同事对象。\r\n" + 
				"\r\n" + 
				"1.5、中介者对象只是提供一个公共的方法，来接受同事对象的通知吗？\r\n" + 
				"	在公共方法里，还是要去区分到底是谁调过来，这还是简单的，还没有去区分到底是什么样的业务触发调用过来的，\r\n" + 
				"因为不同的业务，引起的与其它对象的交互是不一样的。\r\n" + 
				"	因此在实际开发中，通常会提供具体的业务通知方法，这样就不用再去判断到底是什么对象，具体是什么业务了。\r\n" + 
				"\r\n" + 
				"\r\n" + 
				"2、对标准的中介者模式在实际使用中的改进：广义中介者\r\n" + 
				"基于上面的考虑，在实际应用开发中，经常会简化中介者模式，来使开发变得简单，比如有如下的简化：\r\n" + 
				"2.1、通常会去掉同事对象的父类，这样可以让任意的对象，只要需要相互交互，就可以成为同事\r\n" + 
				"2.2、通常不定义Mediator接口，把具体的中介者对象实现成为单例；\r\n" + 
				"2.3、同事对象不再持有中介者，而是在需要的时候直接获取中介者对象并调用。中介者也不再持有同事对象，\r\n" + 
				"而是在具体处方法里面去创建、或者获取、或者从参数传入需要的同事对象\r\n" + 
				"\r\n" + 
				"把这样经过简化、变形使用的情况称为广义中介者。\r\n" + 
				"\r\n" + 
				"五、优点:\r\n" + 
				"\r\n" + 
				"1、松散耦合，各个类之间的解耦\r\n" + 
				"2、集中控制交互\r\n" + 
				"3、降低了类的复杂度，多对多变成一对多，网状结构分离为星型结构\r\n" + 
				"\r\n" + 
				"六、缺点:\r\n" + 
				"\r\n" + 
				"1、过度集中化\r\n" + 
				"2、中介者会庞大，变得复杂难以维护\r\n" + 
				"\r\n" + 
				"七、使用场景:\r\n" + 
				"\r\n" + 
				"1、如果一组对象之间的通信方式比较复杂，导致相互依赖、结构混乱，可以采用中介者模式，把这些对象相互的交互管理起来，\r\n" + 
				"各个对象都只要需要和中介者交互，从而使得各个对象松散耦合，结构也更清晰易懂。\r\n" + 
				"2、如果一个对象引用很多对象，并直接跟这些对象交互，导致难以复用该对象，可以采用中介者模式，\r\n" + 
				"把这个对象跟其他对象的交互封装到中介者对象里面，这个对象就只要中介者对象交互就可以了\r\n" + 
				"\r\n" + 
				"具体场景：\r\n" + 
				"1、WTO之前是各个国家相互贸易，结构复杂，现在是各个国家通过WTO来互相贸易。 \r\n" + 
				"2、机场调度系统。 \r\n" + 
				"3、MVC 框架，其中Controller（控制器）就是 Mode（模型）和 View（视图）的中介者\r\n" + 
				"\r\n" + 
				"八、注意事项:\r\n" + 
				"\r\n" + 
				"1、不应当在职责混乱的时候使用\r\n" + 
				"2、注意使用中介者模式不要产生循环调用，这样会造成死循环\r\n" + 
				"");
	}
}
