package com.mutistic.behavioral.iterator;

import com.mutistic.utils.PrintUtil;

/**
 * @program 迭代器者模式[Iterator Pattern]
 * @description 
 * @author mutisitic
 * @date 2018年8月24日
 */
public class IteratorPattern {
	public static void main(String[] args) {
		PrintUtil.ln("迭代器者模式[Iterator Pattern]");
		PrintUtil.ln("一、定义和本质:\r\n" + 
				"\r\n" + 
				"定义: 提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示\r\n" + 
				"本质: 控制访问聚合对象中的元素\r\n" + 
				"\r\n" + 
				"二、结构和说明:\r\n" + 
				"\r\n" + 
				"Iterator：迭代器接口。定义访问和遍历元素的接口\r\n" + 
				"\r\n" + 
				"ConcreteIterator：具体迭代器实现对象。定义对聚合对象的遍历，并跟踪遍历时的当前位置\r\n" + 
				"\r\n" + 
				"Aggregate：聚合对象。定义创建相应迭代器对象的接口\r\n" + 
				"\r\n" + 
				"ConcreteAggregate：具体聚合对象。实现创建相应的迭代器对象。\r\n" + 
				"\r\n" + 
				"三、理解:\r\n" + 
				"\r\n" + 
				"何时使用：遍历一个聚合对象。\r\n" + 
				"关键代码：定义接口：hasNext, next。\r\n" + 
				"\r\n" + 
				"1、迭代器模式功能：\r\n" + 
				"  迭代器模式的功能主要是在于提供对聚合对象的迭代访问。迭代器就是围绕这个访问延伸出来很多功能。比如：\r\n" + 
				"  以不同的方式遍历聚合对象，比如向前、向后等\r\n" + 
				"  对同一个聚合同事进行多个遍历\r\n" + 
				"  以不同的遍历策略来遍历聚个，比如是否需要过滤等\r\n" + 
				"  多态迭代：为不同的聚合结构，提供统一的迭代接口，也就是说通过一个迭代接口可以访问不同的聚合结构。\r\n" + 
				"标准的迭代模式实现基本上都是支持多态迭代的。多态迭代可能会带来类型安全的问题，可以考虑使用泛型\r\n" + 
				"\r\n" + 
				"2、迭代器模式的关键思想：\r\n" + 
				"  聚合对象的类型很多，如果对聚合对象的迭代访问跟聚合对象本身融合在一起的话，会严重影响到聚合对象的可扩展性和可维护性。\r\n" + 
				"  因此迭代器模式的关键思想就是把对聚合对象的遍历和访问从聚合对象中分离出来，放入到单独的迭代器中，\r\n" + 
				"这样聚合对象会变得简单一些。而且迭代器和聚合对象可以独立的变化和发展，会大大加强系统的灵活性。\r\n" + 
				"\r\n" + 
				"3、Java中最简单的统一访问集合的方式：\r\n" + 
				"  如果只是想要使用一种统一的访问来访问聚合对象，在Java中有更简单的方式，利用Java 5以上版本特性即可。java.util.Iterator\r\n" + 
				"  注意：这种只是从访问形式上一致了，但是暴露了聚合的内部实现，因此不算标准迭代器模式的实现，从某种意义上说，\r\n" + 
				"可以算是隐含的实现了部分迭代器模式的功能\r\n" + 
				"\r\n" + 
				"4、遍历算法：\r\n" + 
				"  在迭代器模式的实现中，常见有两个地方可以来定义遍历算法，一个就是聚合对象本身，另外一个就是迭代器负责遍历算法\r\n" + 
				"  在聚合对象本身定义遍历的算法这种情况下，通常会在遍历过程中，用迭代器来存储当前迭代的状态，这种迭代器被称为游标，\r\n" + 
				"因为它仅用来指示当前的位置\r\n" + 
				"  在迭代器里面定义遍历算法，会易于在相同的聚合上使用不同的迭代算法，同事也易于在不同的聚合上重用相同的算法\r\n" + 
				"\r\n" + 
				"四、写法:\r\n" + 
				"\r\n" + 
				"1、内部迭代器和外部迭代器：\r\n" + 
				"  内部迭代器：指的是由迭代器自己来控制迭代下一个元素的步骤，客户端无法干预，因此，如果想要在迭代的过程中\r\n" + 
				"完成工作的话，客户端就需要把操作传给迭代器，迭代器在迭代的时候会在每个元素上执行这个操作，类似于Java的回调机制\r\n" + 
				"  外部迭代器：指的是由客户端来控制迭代下一个元素的步骤，即显示调用next方法来迭代下一个元素\r\n" + 
				"  总体来说外部迭代器比内部迭代器要灵活一些，因此常见的实现大多属于外部迭代器\r\n" + 
				"\r\n" + 
				"2、使用Java的迭代器：\r\n" + 
				"  在Java中实现地等待期模式是非常简单的，只要实现java.util.Iterator接口即可。而且java的集合框架中的聚合对象，基本上都是提供了迭代器的。\r\n" + 
				"  具体写法：\r\n" + 
				"  不需要在实现Iterator接口，直接实现java.util.Iterator接口即可。\r\n" + 
				"  Java中Iterator接口和标准结构中，需要实现的方法时不一样的。\r\n" + 
				"  集合已经提供了Iterator，那么CollectionIteratorImpl类就不需要实现了\r\n" + 
				"\r\n" + 
				"3、带迭代策略的迭代器：\r\n" + 
				"  由于迭代器模式把聚合对象和访问聚合的机制实现了分离，所以可以在迭代器上实现不同的迭代策略，最为典型的就足实现过滤功能迭代器。\r\n" + 
				"  在实际开发，对于经常被访问的一些数据可以使用缓存，把这些数据存放在内存中。但是不同的业务功能需要访问的数据是不同的，\r\n" + 
				"还有不同的业务访问权限能访问的数据也是不同的，对于这种情况，就可以使用实现过滤功能的迭代器，让不同功能使用不同的迭代器来访问。\r\n" + 
				"当然，这种情况也可以解决策略模式来实现\r\n" + 
				"  在实现过滤功能的迭代器，有两种常见的需要过滤的情况，一种是对数据进行整条过滤，一种是对数据进行部分过滤\r\n" + 
				"\r\n" + 
				"4、双向迭代器：\r\n" + 
				"  所谓双向迭代器的意思就是：可以同事向前和向后遍历数据的迭代器\r\n" + 
				"  在Java util包中的ListIterator接口就是一个双向迭代器。\r\n" + 
				"  自己实现的话只需要在Iterator接口中添加向前和判断和向前获取值的方法，然后在实现类中实现即可。\r\n" + 
				"\r\n" + 
				"5、翻页迭代：\r\n" + 
				"  常见的翻页功能有以下几种：\r\n" + 
				"  纯数据库实现：依靠SQL提供的功能实现翻页，根据用户每次请求翻页的数据，从数据库中查询相应的数据，以时间换空间\r\n" + 
				"  纯内存实现：从数据库中把需要的所有数据取出放在内存中，根据用户的请求翻页数据，从内容中获取相应的数据，以空间换时间\r\n" + 
				"  数据库+内存实现：比如每页显示10条记录，根据判断用户翻页频率，第一次访问从数据库获取前几页数据，然后放在内存中，这样\r\n" + 
				"前几页就可以从内存中后去数据。后几页的数据根据访问统计进行衰减访问，如此操作知道一次冲数据库中获取一页数据\r\n" + 
				"\r\n" + 
				"五、优点:\r\n" + 
				"\r\n" + 
				"1、更好的封装性\r\n" + 
				"2、可以以不同的遍历方式来遍历一个聚合\r\n" + 
				"3、迭代器简化了聚合的接口\r\n" + 
				"4、简化客户端调用\r\n" + 
				"5、在同一个聚合上可以有多个遍历\r\n" + 
				"\r\n" + 
				"六、缺点:\r\n" + 
				"\r\n" + 
				"由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性\r\n" + 
				"\r\n" + 
				"七、使用场景:\r\n" + 
				"\r\n" + 
				"1、希望提供访问一个聚合对象的内容，但又不想暴露其内部表示时，可以使用迭代器模式来提供迭代接口，从而让客户端只是通过迭代器\r\n" + 
				"的接口来访问聚合对象，而无需关心聚合对象的内部实现\r\n" + 
				"2、希望有多重遍历方式可以访问聚合对象\r\n" + 
				"3、希望为遍历不同的聚合对象提供一个统一的接口\r\n" + 
				"\r\n" + 
				"具体场景：\r\n" + 
				"1、Java中的java.util.Collection集合类和java.util.Iterator迭代器\r\n" + 
				"\r\n" + 
				"八、注意事项:\r\n" + 
				"\r\n" + 
				"迭代器模式就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以做到不暴露集合的内部结构，又可让外部代码透明地访问集合内部的数据\r\n" + 
				"");
	}
}
