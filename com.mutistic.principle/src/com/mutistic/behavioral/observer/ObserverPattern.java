package com.mutistic.behavioral.observer;

import com.mutistic.utils.PrintUtil;

/**
 * @program 观察者模式[Observer Pattern]
 * @description 
 * @author mutisitic
 * @date 2018年8月21日
 */
public class ObserverPattern {
	public static void main(String[] args) {
		PrintUtil.ln("观察者模式[Observer Pattern]");
		PrintUtil.one("一、定义和本质:\r\n" + 
				"\r\n" + 
				"定义: 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新\r\n" + 
				"本质: 触发联动\r\n" + 
				"\r\n" + 
				"二、结构和说明:\r\n" + 
				"\r\n" + 
				"Subject：目标对象，通常具有以下功能：\r\n" + 
				"	1、一个目标可以被多个观察者观察\r\n" + 
				"	2、目标提供对观察者注册和退订的维护\r\n" + 
				"	3、当目标的状态发生变化时，目标负责通知所有的注册的、有效的观察者\r\n" + 
				"\r\n" + 
				"ConcreteSubject：具体的目标实现对象，用来维护目标状态，当目标对象的状态发生改变时，通知所有注册有效的观察者，\r\n" + 
				"	让观察者执行相应的处理\r\n" + 
				"\r\n" + 
				"Observer：定义观察者的接口，提供目标通知时对应的更新方法，这个更新方法进行相应的业务处理，\r\n" + 
				"	可以在这个方法里面回调目标对象，以获取目标对象的数据\r\n" + 
				"\r\n" + 
				"ConcreteObserver：观察者的具体实现对象，用来接收目标的通知，并进行相应的后续处理，\r\n" + 
				"	比如更新自身的状态以保持和目标的相应对状态一致\r\n" + 
				"\r\n" + 
				"三、理解:\r\n" + 
				"\r\n" + 
				"主要解决：一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。\r\n" + 
				"如何解决：使用面向对象技术，可以将这种依赖关系弱化。\r\n" + 
				"\r\n" + 
				"1、目标和观察者之间的关系：\r\n" + 
				"  按照模式的定义，目标和观察者之间是典型的一对多的关系。\r\n" + 
				"  但如果只有一个观察者，也是可以的，这样就变相实现了目标和观察者之间一对一的关系\r\n" + 
				"  同样，一个观察者也可以观察多个目标，如果观察者为多个目标定义的通知更新方法都是update方法时，且是同一个updae发放\r\n" + 
				"如果不区分接收目标的话，会导致死循环等问题。需要在方法内部区分接收目标，不同的目标有不同的后续操作。\r\n" + 
				"  一般情况下，观察者应该为不同的观察者目标，实现不同的回调方法，这样实现是最简单的，不要在update方法内部区分\r\n" + 
				"\r\n" + 
				"2、单向依赖：\r\n" + 
				"  在观察者模式中，观察者和目标是单向依赖的，只有观察者依赖于目标，而目标是不会依赖于观察者的。\r\n" + 
				"  它们之间的联系取决于目标，只有目标知道什么时候需要通知观察者，在整个过程中，观察者是被动等待目标通知。\r\n" + 
				"  对目标而言，所有的观察者都是同一级别的。但也可以通过在目标里面进行控制，实现有区别对待观测者\r\n" + 
				"这是在标准的、原始的观察者模式的稍微变形用法。\r\n" + 
				"\r\n" + 
				"3、基本的实现说明：\r\n" + 
				"  具体的目标实现对象要能维护观察者的注册信息，最简厂的实现方案就是采用一个集合来保存观察者的注册信息。\r\n" + 
				"  具体的目标实现对象需要维护引起通知的状态，一般情况下是目标自身的状态，变形使用的情况下，也可以是别的对象的状态。\r\n" + 
				"  具体的观察者实现对象需要能接收目标的通知，能够接收目标传递的数据或者是能够主动去获取目标的数据，并进行后续处理。\r\n" + 
				"  如果是一个观察者观察多个目标，那么在观察者的更新方法里曲，需要去判断是来自哪一个目标的通知。\r\n" + 
				"简单的解决方案就是扩展update方法，比如在方法里面多传递一个参数过行区分。还有一种简单的方法，比如定义不同的回调方法。\r\n" + 
				"\r\n" + 
				"4、观察者模式又被称为发布-订阅模式\r\n" + 
				"\r\n" + 
				"5、触发通知的时机：一般情况下，是在完成了状态维护后触发，因为通知会传递数据，不能够先通知后改数据，否则会导致观察者和目标对象的状态不一致\r\n" + 
				"\r\n" + 
				"6、相互观察：A对象的状态变化会引起C对象的联动操作，反过来，C对象的变化也会引起A对象的联动操作。对于这种状况，要小心处理，避免循环通知\r\n" + 
				"否则会引起死循环的情况（中介者模式不处理好循环调用也可能导致死循环）\r\n" + 
				"\r\n" + 
				"7、通知顺序：从理论上说，当目标对象的状态变化后通知所有观察者的时候，顺序是不确定的，因此观察者实现的功能，不要依赖于通知的顺序，\r\n" + 
				"也就是说，多个观察者之间的功能是平行的，相互不应该有先后的依赖关系。如果需要顺序可以采用责任链模式\r\n" + 
				"\r\n" + 
				"四、写法:\r\n" + 
				"\r\n" + 
				"1、推模型：目标对象主动向观察者推动目标的详细信息，不管观察者是否需要，推送的信息通常识目标对象的全部或部分数据，相当于是在广播通信\r\n" + 
				"\r\n" + 
				"2、拉模型：木料对象在通知观察者的时候值传递少量信息，如果观察者需要更具体的信息，由观察者主动到目标对象中获取，\r\n" + 
				"相当于是观察者从目标对象中那数据，一般这种模型的实现，会把目标对象自身通过update方法传递给观察者，这样在观察者\r\n" + 
				"需要获取数据的时候，就可以通过这个应用来获取了。标准的、原始的观察者模式是拉模型。\r\n" + 
				"\r\n" + 
				"3、推模型和拉模型的比较：\r\n" + 
				"  推模型是假定目标对象知道观察者需要的数据：而拉模型是目标对象不知道观察者具体需要什么数据，\r\n" + 
				"没有办法的情况下，直接把自身传给观察者，让观察者按需取值\r\n" + 
				"  推模型可能会使得观察者对象难以复用，因为观察者定义的update方法是按需而定义的，可能无法兼顾没有考到的使用情况。\r\n" + 
				"这就意味着出现新情况的时候，就可能需要提供新的update方法，或者是重新实现观察者。\r\n" + 
				"  而拉模型就不会造成这样的情况，因为拉模型下，update方法的参数是目标对象本身，这基本上是目标对象能传递的最大数据集合了，\r\n" + 
				"基本上可以适应各种情况的需要。\r\n" + 
				"\r\n" + 
				"4、Java中的观察者模式：java.util.Observable 实现了大部分我们需要的目标的功能，还有一个java.util.Observer接口，\r\n" + 
				"里面定义了一个update的方法，就是观察者的接口\r\n" + 
				"\r\n" + 
				"5、Swing中的观察者模式： \r\n" + 
				"  Swing中到处都是观察者模式的身影，比如事件处理（早期的Swing事件处理用的是职责链）\r\n" + 
				"  Swing组件是被观察的目标，而每个实现监听器的类就是观察者，监听器的就扣就是观察者的接口，在调用addListener方法\r\n" + 
				"的时候就相当于注册观察者。\r\n" + 
				"  当组件被点击，状态发生改变的时候，就会产生相应的通知，会调用注册的观察者的方法，就是我们说实现实现的监听器的方法\r\n" + 
				"\r\n" + 
				"6、区别对象观察者：\r\n" + 
				"\r\n" + 
				"五、优点:\r\n" + 
				"\r\n" + 
				"1、观察者模式实现了观察者和目标之间的抽象耦合\r\n" + 
				"2、观察者模式实现了动态联动，建立一套触发机制。 \r\n" + 
				"3、观察者模式支持广播通信\r\n" + 
				"\r\n" + 
				"六、缺点:\r\n" + 
				"\r\n" + 
				"1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 2、如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化\r\n" + 
				"4、观察者模式可能会引起无谓的操作\r\n" + 
				"\r\n" + 
				"七、使用场景:\r\n" + 
				"\r\n" + 
				"1、当一个抽象模型有两个方面，其中一个方面的操作依赖于另一个方面的状态变化，可以选用观察者模式\r\n" + 
				"2、如果在更改一个对象的时候，需要同时连带改变其他的对象，而且不知道究竟应该有多少对象需要被连带改变，\r\n" + 
				"可以选用观察者模式，被更改的对象相当于目标对象，需要连带修改的其他对象相当于观察者对象\r\n" + 
				"3、当一个对象必须通知其他的对象，当不希望这个对象和其他被其通知的对象是松散耦合的，也就是说这个对象\r\n" + 
				"无需知道具体被通知的对象，可以选用观察者模式，这个对象相当于目标对象，被通知的对象相当于观察者对象\r\n" + 
				"\r\n" + 
				"具体场景：\r\n" + 
				"\r\n" + 
				"八、注意事项:\r\n" + 
				"\r\n" + 
				"1、JAVA 中已经有了对观察者模式的支持类。 \r\n" + 
				"2、避免循环通知，否则会引起死循环。 \r\n" + 
				"3、如果同步执行，某一观察者错误会导致后续的观察者通知失败，一般采用异步方式。\r\n" + 
				"4、通知观察者不建议依赖于通知的顺序。如果无法避免建议采用责任链模式\r\n" + 
				"");
	}
}
