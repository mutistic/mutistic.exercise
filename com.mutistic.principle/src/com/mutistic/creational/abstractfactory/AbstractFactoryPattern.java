package com.mutistic.creational.abstractfactory;

import com.mutistic.utils.PrintUtil;

/**
 * @program 抽象工厂模式[Abstract Factory Pattern]
 * @description 
 * @author mutisitic
 * @date 2018年8月21日
 */
public class AbstractFactoryPattern {
	public static void main(String[] args) {
		PrintUtil.ln("抽象工厂模式[Abstract Factory Pattern]");
		PrintUtil.one("一、定义:\r\n" + 
				"\r\n" + 
				"定义: 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类\r\n" + 
				"本质: 选择产品簇的实现\r\n" + 
				"\r\n" + 
				"二、结构和说明:\r\n" + 
				"\r\n" + 
				"AbstractFactory: 抽象工厂，定义创建一系列产品对象的操作接口\r\n" + 
				"\r\n" + 
				"ConcreteFactory: 具体的工厂，实现抽象工厂定义的方法，具体实现一系列产品对象的创建\r\n" + 
				"\r\n" + 
				"AbstractProduct: 定义一类产品对象的接口\r\n" + 
				"\r\n" + 
				"ConcreteProduct: 具体的产品实现对象，通过在具体工厂里面，\r\n" + 
				"	会选择具体的产品实现对象来创建符合抽象工厂定义的方法返回的产品的对象。\r\n" + 
				"\r\n" + 
				"Clien: 客户端，主要使用抽象工厂来获取一些列所需要的产品对象，\r\n" + 
				"	然后面对这些产品对象的接口变成，以实现需要的功能\r\n" + 
				"\r\n" + 
				"三、理解:\r\n" + 
				"\r\n" + 
				"主要解决: 主要解决接口选择的问题。\r\n" + 
				"如何解决: 在一个产品族里面，定义多个产品。 \r\n" + 
				"\r\n" + 
				"1、抽象工厂模式: 是为了一系列相关对象或相互依赖的对象创建的一个接口。\r\n" + 
				"	从某种意义上看，抽象工厂其实是一个产品系列，或者产品簇\r\n" + 
				"\r\n" + 
				"2、实现成接口: AbstractFactory在Java中通常实现成为接口。当然也可以实现成为抽象类。\r\n" + 
				"\r\n" + 
				"3、使用工厂方法: AbstractFactory定义了创建产品所需要的接口，具体的实现是在实现类中。\r\n" + 
				"	通常在实现类里面就需要选择多种更具体的实现，所以AbstractFactory定义的创建产品的方法可以看成是工厂方法\r\n" + 
				"	而这些工厂方法的具体实现就延迟到了具体的工厂里面。也就是说使用工厂方法来实现抽象工厂\r\n" + 
				"\r\n" + 
				"4、切换产品簇: 抽象工厂定义了一个产品簇，因此切换产品簇的时候提供不同的抽象工厂即可。\r\n" + 
				"\r\n" + 
				"四、写法:\r\n" + 
				"\r\n" + 
				"1、定义可扩展的工厂: 抽象工厂里面不是通过定义很多创建产品的方法。而是定义一个方法，\r\n" + 
				"	通过参数的方式来判断具体创建什么产品对象（简单工厂模式）。由于只有一个方法，\r\n" + 
				"	返回类型只能定义成所有产品都实现的某个接口或Object，会存在类型转换错误的问题。\r\n" + 
				"\r\n" + 
				"2、J2EE中的数据访问对象模式[Data Access Object Pattern]的设计思想是采用了抽象工厂模式\r\n" + 
				"\r\n" + 
				"五、优点:\r\n" + 
				"\r\n" + 
				"1、分离接口和实现\r\n" + 
				"2、是的切换产品簇变得容易\r\n" + 
				"3、当一个产品簇中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品簇中的对象\r\n" + 
				"\r\n" + 
				"六、缺点:\r\n" + 
				"\r\n" + 
				"1、不太容易扩展新的产品: 添加新的产品会导致所有的ConcreteFactory都要重新实现该产品。\r\n" + 
				"2、容易造成类层次复杂\r\n" + 
				"\r\n" + 
				"七、使用场景:\r\n" + 
				"\r\n" + 
				"1、系统独立于它的产品的创建、组合和表示的时候，即：系统只知道产品的接口，而不关心具体实现\r\n" + 
				"2、系统要由多个产品系统中的一个来配置时，即：可以动态切换产品簇时\r\n" + 
				"3、强调一些列相关产品的接口，以便联合使用它们时\r\n" + 
				"\r\n" + 
				"具体场景：\r\n" + 
				"1、生成不同操作系统的程序\r\n" + 
				"2、J2EE中的数据访问对象模式[Data Access Object Pattern]\r\n" + 
				"\r\n" + 
				"八、注意事项:\r\n" + 
				"\r\n" + 
				"产品簇难扩展，产品等级易扩展\r\n" + 
				"");
	}
}
