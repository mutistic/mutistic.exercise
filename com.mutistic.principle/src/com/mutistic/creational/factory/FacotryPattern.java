package com.mutistic.creational.factory;

import com.mutistic.utils.PrintUtil;

/**
 * @program 工厂模式[Factory Pattern]
 * @description 
 * @author mutisitic
 * @date 2018年8月21日
 */
public class FacotryPattern {
	public static void main(String[] args) {
		PrintUtil.ln("工厂模式[Factory Pattern]");
		PrintUtil.one("一、定义:\r\n" + 
				"\r\n" + 
				"定义: 定义一个用于创建对象的接口，让子类决定实例化哪一个类，Factory Method使一个类的实例化延迟到子类\r\n" + 
				"本质: 延迟到子类来选择实现\r\n" + 
				"原则：工厂模式体现了依赖倒置原则[DIP: Dependence Inversion Principle]\r\n" + 
				"\r\n" + 
				"二、结构和说明:\r\n" + 
				"\r\n" + 
				"Product: 定义工厂方法所创建的对象的接口，也就是实际需要使用的对象的接口。\r\n" + 
				"\r\n" + 
				"ConcreteProduce: 具体的Product接口的实现对象\r\n" + 
				"\r\n" + 
				"Creator: 创建器，声明工厂的抽象方法\r\n" + 
				"\r\n" + 
				"ConcreteCreator: 具体的创建对象，覆盖实现Creator定义的工厂方法，返回具体的Product实例\r\n" + 
				"\r\n" + 
				"三、理解:\r\n" + 
				"\r\n" + 
				"主要解决: 主要解决接口选择的问题。\r\n" + 
				"如何解决: 让其子类实现工厂接口，返回的也是一个抽象的产品。\r\n" + 
				"\r\n" + 
				"1、工厂模式的功能：让父类在不知道具体实现的情况下，完成自身的功能调用，而具体的实现延迟到子类来实现\r\n" + 
				"2、实现成抽象类：工厂方法的实现中，通常父类会死一个抽象类，里面包含创建所需对象的抽象方法，\r\n" + 
				"	这些抽象方法就是工厂方法。\r\n" + 
				"\r\n" + 
				"3、实现成具体类：可以把父类是县城一个具体的类，这种情况下，通常是在父类中提供获取所需要对象的默认实现方法，\r\n" + 
				"	这样就算没有具体的子类，也能运行\r\n" + 
				"\r\n" + 
				"4、工厂方法的实现中：可能需要参数，以便于决定选用哪一种具体的实现。（此时也简单工厂模式的核心是重合的）\r\n" + 
				"	一般工厂方法返回的是被创建对象的接口对象，当然也可以是抽象类或者一个具体的类。\r\n" + 
				"\r\n" + 
				"PS: 简单工厂模式的最大优点在于工厂类包含了必要的逻辑判断，根据客户端的选择条件动态实例化相关的类，\r\n" + 
				"对于客户端来说，去除了与具体产品的依赖\r\n" + 
				"\r\n" + 
				"四、写法:\r\n" + 
				"\r\n" + 
				"1、在工厂方法模式里面：应该是由Creator中的其他业务方法，使用工厂方法facaotryMethod创建的对象\r\n" + 
				"2、客户端应该 使用Creator对象，或者是使用由Creator创建出来的对象，这时工厂方法创建的对象，是Creator中的某些方法使用\r\n" + 
				"3、在某些情况下，客户端可能会使用由Creator创建出来的对象，这个时候工厂方法创建的对象，是构成客户端需要的对象的一部分。\r\n" + 
				"\r\n" + 
				"在工厂方法模式中，客户端要么使用Creator对象，要么使用Creator创建的对象，一般不直接使用工厂方法factoryMethod。\r\n" + 
				"虽然可以吧工厂方法暴露给客户端操作，但是一般不这么做\r\n" + 
				"\r\n" + 
				"五、优点:\r\n" + 
				"\r\n" + 
				"1、屏蔽产品的具体实现，调用者只关心产品的接口\r\n" + 
				"2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以\r\n" + 
				"3、连接平行的类层次\r\n" + 
				"\r\n" + 
				"六、缺点:\r\n" + 
				"\r\n" + 
				"1、具体产品对象和工厂方法的耦合性\r\n" + 
				"2、次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，\r\n" + 
				"在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖\r\n" + 
				"\r\n" + 
				"七、使用场景:\r\n" + 
				"\r\n" + 
				"1、如果一个类需要创建某个接口的对象，但又不知道具体的实现，可以选用工厂模式把创建对象的工作延迟到子类去实现。\r\n" + 
				"2、如果一个类本身就需要由它的子类来创建所需要的对象，就应该使用工厂模式\r\n" + 
				"\r\n" + 
				"具体场景：\r\n" + 
				"1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 3、设计一个连接服务器的框架，需要三个协议，\"POP3\"、\"IMAP\"、\"HTTP\"，可以把这三个作为产品类，共同实现一个接口\r\n" + 
				"\r\n" + 
				"八、注意事项:\r\n" + 
				"\r\n" + 
				"作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。\r\n" + 
				"有一点需要注意的地方就是复杂对象适合使用工厂模式，\r\n" + 
				"而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。\r\n" + 
				"如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度\r\n" + 
				"");
	}
}
