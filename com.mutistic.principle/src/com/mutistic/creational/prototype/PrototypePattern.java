package com.mutistic.creational.prototype;

import com.mutistic.utils.PrintUtil;

/**
 * @program 原型模式[Prototype Pattern]
 * @description 
 * @author mutisitic
 * @date 2018年8月21日
 */
public class PrototypePattern {
	public static void main(String[] args) {
		PrintUtil.ln("原型模式[Prototype Pattern]");
		PrintUtil.one("一、定义:\r\n" + 
				"\r\n" + 
				"定义: 用原型实例执行创建对象的种类，并通过拷贝这些原型创建新的对象\r\n" + 
				"本质: 克隆生成对象\r\n" + 
				"\r\n" + 
				"二、结构和说明:\r\n" + 
				"\r\n" + 
				"Prototype: 声明一个克隆自身的接口，用来约束想要克隆自己的类，要求他们都要实现这里定义的克隆方法\r\n" + 
				"\r\n" + 
				"ConcretePrototype: 实现Prototype接口的类，这些类真正实现克隆自身的功能\r\n" + 
				"\r\n" + 
				"Client: 使用原型的客户端，首先要获取到原型实例对象，然后通过原型实例克隆自身来创建新的对象实例\r\n" + 
				"\r\n" + 
				"三、理解:\r\n" + 
				"\r\n" + 
				"主要解决: 在运行期建立和删除原型。\r\n" + 
				"如何解决: 利用已有的一个原型对象，快速地生成和原型对象一样的实例。\r\n" + 
				"\r\n" + 
				"1、原型模式的功能: 包含两个方面: \r\n" + 
				"	一个是通过克隆来创建新的对象实例。\r\n" + 
				"	一个是为克隆出来的新的对象实例赋值原型实例属性的值\r\n" + 
				"原型模式要实现的就是: 通过克隆来创建新的对象实例，一般情况下，新创建出来的实例的数据和原型实例是一样的。\r\n" + 
				"但是具体如何实现克隆，需要由程序自行实现，原型模式并没有统一的要求和实现算法。\r\n" + 
				"\r\n" + 
				"2、原型与new: 原型模式从某种意义说，类似new操作，但不是new。\r\n" + 
				"	因为使用原型模式要克隆原型的属性值，而通过new出来的属性一般是null或默认值。\r\n" + 
				"\r\n" + 
				"3、原型实例和克隆实例: 原型实例和克隆出来的实例，本质上市不同的实例，克隆完成后，它们之间是没有关联的，\r\n" + 
				"	如果克隆后，克隆实例的属性值发生改变，是不会影响到原型实例的，包括引用对象，应该是深度克隆。\r\n" + 
				"\r\n" + 
				"4、Java中的克隆方法: \r\n" + 
				"	在Java中已经提供了clone方法，定义在Object类中。需要克隆功能需要实现 java.lang.Cloneable接口，\r\n" + 
				"	这个接口只是一个表示接口，没有需要实现的方法，注意此刻克隆是浅度克隆。\r\n" + 
				"\r\n" + 
				"5、浅度克隆和深度克隆: \r\n" + 
				"	浅度克隆: 自负责克隆按值传递的数据（基本数据类型、String类型）\r\n" + 
				"	深度克隆: 除了浅度克隆要克隆的值外，还负责克隆引用类型数据，基本上就是克隆所有的属性的数据。\r\n" + 
				"		深度克隆如果要克隆的属性数据是引用类型，那么需要一直递归的克隆下去。\r\n" + 
				"		这意味着想要深度克隆成功，必须要整个恐龙所设计的对象都要正确实现克隆方法，\r\n" + 
				"		如果其中有一个没有正确实现克隆，那么就不是严格意义上的深度克隆\r\n" + 
				"\r\n" + 
				"四、写法:\r\n" + 
				"\r\n" + 
				"1、原型管理器: 如果系統中原型的数目不固定，比如系统中的原型可以被动态的创建和销毁，那么就需要在系统中维护\r\n" + 
				"一个当前可用的原型的注册表，这个注册表就被成为原型管理器。\r\n" + 
				"	如果把原型当成一个资源的话，原型管理器就相当于一个资源管理器，在系统开始运行的时候初始化，\r\n" + 
				"然后运行期间可以动态的添加资源和销毁资源。从这个角度看，原型管理器就可以相当于一个缓存资源的实现，\r\n" + 
				"值不够里面的缓存和管理的是原型实例。\r\n" + 
				"	在原型管理器，一般情况下添加原型对象是通过new来创造对象，其他操作通过通过克隆方法来获取新的对象实例。\r\n" + 
				"这样就可以实现动态管理、或者动态切换具体的实现对象实例。\r\n" + 
				"\r\n" + 
				"五、优点:\r\n" + 
				"\r\n" + 
				"1、性能提高、逃避构造函数的约束\r\n" + 
				"2、对客户算隐藏具体的实现类型\r\n" + 
				"3、在运行时动态改变具体的实现类型\r\n" + 
				"\r\n" + 
				"六、缺点:\r\n" + 
				"\r\n" + 
				"1、深度克隆方法实现会比较复杂\r\n" + 
				"1、配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，\r\n" + 
				"特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。\r\n" + 
				"2、使用Object的clone方法必须实现 java.lang.Cloneable 接口\r\n" + 
				"\r\n" + 
				"七、使用场景:\r\n" + 
				"\r\n" + 
				"1、如果系统要独立于它想要使用的对象时，使用原型模式，让系统只面向接口编成，\r\n" + 
				"在系统需要新的对象的时候，可以用克隆原型来得到\r\n" + 
				"\r\n" + 
				"2、如果需要实例化的类时在运行时动态指定时，使用原型模式，通过克隆原型来得到需要的实例\r\n" + 
				"\r\n" + 
				"具体场景：\r\n" + 
				"1、资源优化场景。 \r\n" + 
				"2、类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。 \r\n" + 
				"3、性能和安全要求的场景。 \r\n" + 
				"4、通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。 \r\n" + 
				"5、一个对象多个修改者的场景。 6、一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。 7、在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者\r\n" + 
				"\r\n" + 
				"八、注意事项:\r\n" + 
				"\r\n" + 
				"与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的。\r\n" + 
				"浅拷贝实现 Cloneable，重写，深拷贝是通过实现 Serializable 读取二进制流。\r\n" + 
				"");
	}
}
